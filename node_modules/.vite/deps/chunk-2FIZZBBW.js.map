{
  "version": 3,
  "sources": ["../../motion/dist/es/motion-dom/dist/es/gestures/drag/state/is-active.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/resolve-elements.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/utils/setup.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/hover.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/utils/capture-pointer.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/press/utils/state.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/press/utils/keyboard.mjs", "../../motion/dist/es/motion-dom/dist/es/gestures/press/index.mjs", "../../motion/dist/es/motion-utils/dist/es/noop.mjs", "../../motion/dist/es/motion-utils/dist/es/errors.mjs", "../../motion/dist/es/motion-utils/dist/es/progress.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/clamp.mjs", "../../motion/dist/es/motion-utils/dist/es/time-conversion.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/spring/defaults.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/spring/find.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/waapi/utils/linear.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/velocity-per-second.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/utils/velocity.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/spring/index.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/wrap.mjs", "../../motion/dist/es/framer-motion/dist/es/value/utils/is-motion-value.mjs", "../../motion/dist/es/framer-motion/dist/es/render/store.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/GlobalConfig.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/order.mjs", "../../motion/dist/es/framer-motion/dist/es/stats/buffer.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/render-step.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/batcher.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/frame.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/sync-time.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/array.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/subscription-manager.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/warn-once.mjs", "../../motion/dist/es/framer-motion/dist/es/value/index.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/optimized-appear/data-id.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/cubic-bezier.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/modifiers/mirror.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/modifiers/reverse.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/back.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/anticipate.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/circ.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/numbers/units.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/numbers/index.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/utils/sanitize.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/utils/float-regex.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/utils/is-nullish.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/utils/single-color-regex.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/color/utils.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/color/rgba.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/color/hex.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/color/hsla.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/color/index.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/utils/color-regex.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/complex/index.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/pipe.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/number.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/hsla-to-rgba.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/immediate.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/color.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/visibility.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/complex.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/mix/index.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/inertia.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/ease.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/interpolate.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/utils/is-easing-array.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/is-bezier-definition.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/utils/map.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/offsets/fill.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/offsets/default.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/offsets/time.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/generators/keyframes.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/generators/utils/is-generator.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/keys-transform.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/KeyframesResolver.mjs", "../../motion/dist/es/framer-motion/dist/es/stats/animation-count.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/use-instant-transition-state.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-animatable.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/utils/can-animate.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/BaseAnimation.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs", "../../motion/dist/es/motion-utils/dist/es/memo.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/supports/flags.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/supports/memo.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/supports/linear-easing.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/waapi/utils/easing.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/is-zero-value-string.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-none.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/keys-position.mjs", "../../motion/dist/es/framer-motion/dist/es/value/types/complex/filter.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/number-browser.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/transform.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/type-int.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/number.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/defaults.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/is-numerical-string.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/test.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/type-auto.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/dimensions.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/index.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/geometry/models.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/is-browser.mjs", "../../motion/dist/es/framer-motion/dist/es/motion/features/definitions.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/reduced-motion/state.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/reduced-motion/index.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/find.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-animation-controls.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/is-variant-label.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/variant-props.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/is-controlling-variants.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/motion-values.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/resolve-variants.mjs", "../../motion/dist/es/framer-motion/dist/es/render/VisualElement.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/build-transform.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/styles/scale-correction.mjs", "../../motion/dist/es/motion-dom/dist/es/utils/supports/scroll-timeline.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/controls/BaseGroup.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/controls/Group.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animate/resolve-subjects.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/utils/calc-repeat-duration.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/utils/edit.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/utils/normalize-times.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/utils/sort.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/sequence/create.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/utils/get-value-transition.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/resolve-value.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs", "../../motion/dist/es/framer-motion/dist/es/render/utils/setters.mjs", "../../motion/dist/es/framer-motion/dist/es/value/use-will-change/is.mjs", "../../motion/dist/es/framer-motion/dist/es/value/use-will-change/add-will-change.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/default-transitions.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/is-transition-defined.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/interfaces/motion-value.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/DOMVisualElement.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/build-styles.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/path.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/transform-origin.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/build-attrs.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/measure.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/render.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/render.mjs", "../../motion/dist/es/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs", "../../motion/dist/es/framer-motion/dist/es/render/svg/SVGVisualElement.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/geometry/conversion.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/utils/has-transform.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/geometry/delta-apply.mjs", "../../motion/dist/es/framer-motion/dist/es/projection/utils/measure.mjs", "../../motion/dist/es/framer-motion/dist/es/render/html/HTMLVisualElement.mjs", "../../motion/dist/es/framer-motion/dist/es/render/object/ObjectVisualElement.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/create-visual-element.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animate/single-value.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animate/subject.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animate/sequence.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animate/index.mjs", "../../motion/dist/es/motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/utils/style.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/utils/supports-partial-keyframes.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/NativeAnimation.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/animators/waapi/animate-style.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/resize/handle-element.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/resize/handle-window.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/resize/index.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/info.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/track.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/observe.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/scroll/index.mjs", "../../motion/dist/es/framer-motion/dist/es/render/dom/viewport/index.mjs", "../../motion/dist/es/framer-motion/dist/es/easing/steps.mjs", "../../motion/dist/es/framer-motion/dist/es/animation/utils/stagger.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/delay.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/distance.mjs", "../../motion/dist/es/framer-motion/dist/es/utils/transform.mjs", "../../motion/dist/es/framer-motion/dist/es/frameloop/index-legacy.mjs"],
  "sourcesContent": ["const isDragging = {\r\n    x: false,\r\n    y: false,\r\n};\r\nfunction isDragActive() {\r\n    return isDragging.x || isDragging.y;\r\n}\r\n\r\nexport { isDragActive, isDragging };\r\n", "function resolveElements(elementOrSelector, scope, selectorCache) {\r\n    var _a;\r\n    if (elementOrSelector instanceof EventTarget) {\r\n        return [elementOrSelector];\r\n    }\r\n    else if (typeof elementOrSelector === \"string\") {\r\n        let root = document;\r\n        if (scope) {\r\n            // TODO: Refactor to utils package\r\n            // invariant(\r\n            //     Boolean(scope.current),\r\n            //     \"Scope provided, but no element detected.\"\r\n            // )\r\n            root = scope.current;\r\n        }\r\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\r\n        return elements ? Array.from(elements) : [];\r\n    }\r\n    return Array.from(elementOrSelector);\r\n}\r\n\r\nexport { resolveElements };\r\n", "import { resolveElements } from '../../utils/resolve-elements.mjs';\r\n\r\nfunction setupGesture(elementOrSelector, options) {\r\n    const elements = resolveElements(elementOrSelector);\r\n    const gestureAbortController = new AbortController();\r\n    const eventOptions = {\r\n        passive: true,\r\n        ...options,\r\n        signal: gestureAbortController.signal,\r\n    };\r\n    const cancel = () => gestureAbortController.abort();\r\n    return [elements, eventOptions, cancel];\r\n}\r\n\r\nexport { setupGesture };\r\n", "import { isDragActive } from './drag/state/is-active.mjs';\r\nimport { setupGesture } from './utils/setup.mjs';\r\n\r\nfunction isValidHover(event) {\r\n    return !(event.pointerType === \"touch\" || isDragActive());\r\n}\r\n/**\r\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\r\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\r\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\r\n *\r\n * @public\r\n */\r\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\r\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\r\n    const onPointerEnter = (enterEvent) => {\r\n        if (!isValidHover(enterEvent))\r\n            return;\r\n        const { target } = enterEvent;\r\n        const onHoverEnd = onHoverStart(target, enterEvent);\r\n        if (typeof onHoverEnd !== \"function\" || !target)\r\n            return;\r\n        const onPointerLeave = (leaveEvent) => {\r\n            if (!isValidHover(leaveEvent))\r\n                return;\r\n            onHoverEnd(leaveEvent);\r\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\r\n        };\r\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\r\n    };\r\n    elements.forEach((element) => {\r\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\r\n    });\r\n    return cancel;\r\n}\r\n\r\nexport { hover };\r\n", "function capturePointer(event, action) {\r\n    const actionName = `${action}PointerCapture`;\r\n    if (event.target instanceof Element &&\r\n        actionName in event.target &&\r\n        event.pointerId !== undefined) {\r\n        try {\r\n            event.target[actionName](event.pointerId);\r\n        }\r\n        catch (e) { }\r\n    }\r\n}\r\n\r\nexport { capturePointer };\r\n", "/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nconst isNodeOrChild = (parent, child) => {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\r\n\r\nexport { isNodeOrChild };\r\n", "const isPrimaryPointer = (event) => {\r\n    if (event.pointerType === \"mouse\") {\r\n        return typeof event.button !== \"number\" || event.button <= 0;\r\n    }\r\n    else {\r\n        /**\r\n         * isPrimary is true for all mice buttons, whereas every touch point\r\n         * is regarded as its own input. So subsequent concurrent touch points\r\n         * will be false.\r\n         *\r\n         * Specifically match against false here as incomplete versions of\r\n         * PointerEvents in very old browser might have it set as undefined.\r\n         */\r\n        return event.isPrimary !== false;\r\n    }\r\n};\r\n\r\nexport { isPrimaryPointer };\r\n", "const focusableElements = new Set([\r\n    \"BUTTON\",\r\n    \"INPUT\",\r\n    \"SELECT\",\r\n    \"TEXTAREA\",\r\n    \"A\",\r\n]);\r\nfunction isElementKeyboardAccessible(element) {\r\n    return (focusableElements.has(element.tagName) ||\r\n        element.tabIndex !== -1);\r\n}\r\n\r\nexport { isElementKeyboardAccessible };\r\n", "const isPressing = new WeakSet();\r\n\r\nexport { isPressing };\r\n", "import { isPressing } from './state.mjs';\r\n\r\n/**\r\n * Filter out events that are not \"Enter\" keys.\r\n */\r\nfunction filterEvents(callback) {\r\n    return (event) => {\r\n        if (event.key !== \"Enter\")\r\n            return;\r\n        callback(event);\r\n    };\r\n}\r\nfunction firePointerEvent(target, type) {\r\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\r\n}\r\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\r\n    const element = focusEvent.currentTarget;\r\n    if (!element)\r\n        return;\r\n    const handleKeydown = filterEvents(() => {\r\n        if (isPressing.has(element))\r\n            return;\r\n        firePointerEvent(element, \"down\");\r\n        const handleKeyup = filterEvents(() => {\r\n            firePointerEvent(element, \"up\");\r\n        });\r\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\r\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\r\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\r\n    });\r\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\r\n    /**\r\n     * Add an event listener that fires on blur to remove the keydown events.\r\n     */\r\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\r\n};\r\n\r\nexport { enableKeyboardPress };\r\n", "import { isDragActive } from '../drag/state/is-active.mjs';\r\nimport { capturePointer } from '../utils/capture-pointer.mjs';\r\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\r\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\r\nimport { setupGesture } from '../utils/setup.mjs';\r\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\r\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\r\nimport { isPressing } from './utils/state.mjs';\r\n\r\n/**\r\n * Filter out events that are not primary pointer events, or are triggering\r\n * while a Motion gesture is active.\r\n */\r\nfunction isValidPressEvent(event) {\r\n    return isPrimaryPointer(event) && !isDragActive();\r\n}\r\n/**\r\n * Create a press gesture.\r\n *\r\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\r\n * automatically filters out secondary pointer events like right\r\n * click and multitouch.\r\n *\r\n * It also adds accessibility support for keyboards, where\r\n * an element with a press gesture will receive focus and\r\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\r\n *\r\n * This is different to a browser's `\"click\"` event, which does\r\n * respond to keyboards but only for the `\"click\"` itself, rather\r\n * than the press start and end/cancel. The element also needs\r\n * to be focusable for this to work, whereas a press gesture will\r\n * make an element focusable by default.\r\n *\r\n * @public\r\n */\r\nfunction press(targetOrSelector, onPressStart, options = {}) {\r\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\r\n    const startPress = (startEvent) => {\r\n        const target = startEvent.currentTarget;\r\n        if (!target || !isValidPressEvent(startEvent) || isPressing.has(target))\r\n            return;\r\n        isPressing.add(target);\r\n        capturePointer(startEvent, \"set\");\r\n        const onPressEnd = onPressStart(target, startEvent);\r\n        const onPointerEnd = (endEvent, success) => {\r\n            target.removeEventListener(\"pointerup\", onPointerUp);\r\n            target.removeEventListener(\"pointercancel\", onPointerCancel);\r\n            capturePointer(endEvent, \"release\");\r\n            if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\r\n                return;\r\n            }\r\n            isPressing.delete(target);\r\n            if (typeof onPressEnd === \"function\") {\r\n                onPressEnd(endEvent, { success });\r\n            }\r\n        };\r\n        const onPointerUp = (upEvent) => {\r\n            const isOutside = !upEvent.isTrusted\r\n                ? false\r\n                : checkOutside(upEvent, target instanceof Element\r\n                    ? target.getBoundingClientRect()\r\n                    : {\r\n                        left: 0,\r\n                        top: 0,\r\n                        right: window.innerWidth,\r\n                        bottom: window.innerHeight,\r\n                    });\r\n            if (isOutside) {\r\n                onPointerEnd(upEvent, false);\r\n            }\r\n            else {\r\n                onPointerEnd(upEvent, !(target instanceof Element) ||\r\n                    isNodeOrChild(target, upEvent.target));\r\n            }\r\n        };\r\n        const onPointerCancel = (cancelEvent) => {\r\n            onPointerEnd(cancelEvent, false);\r\n        };\r\n        target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\r\n        target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\r\n        target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\r\n    };\r\n    targets.forEach((target) => {\r\n        target = options.useGlobalTarget ? window : target;\r\n        let canAddKeyboardAccessibility = false;\r\n        if (target instanceof HTMLElement) {\r\n            canAddKeyboardAccessibility = true;\r\n            if (!isElementKeyboardAccessible(target) &&\r\n                target.getAttribute(\"tabindex\") === null) {\r\n                target.tabIndex = 0;\r\n            }\r\n        }\r\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\r\n        if (canAddKeyboardAccessibility) {\r\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\r\n        }\r\n    });\r\n    return cancelEvents;\r\n}\r\nfunction checkOutside(event, rect) {\r\n    return (event.clientX < rect.left ||\r\n        event.clientX > rect.right ||\r\n        event.clientY < rect.top ||\r\n        event.clientY > rect.bottom);\r\n}\r\n\r\nexport { press };\r\n", "/*#__NO_SIDE_EFFECTS__*/\r\nconst noop = (any) => any;\r\n\r\nexport { noop };\r\n", "import { noop } from './noop.mjs';\r\n\r\nlet warning = noop;\r\nlet invariant = noop;\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    warning = (check, message) => {\r\n        if (!check && typeof console !== \"undefined\") {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = (check, message) => {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\r\n\r\nexport { invariant, warning };\r\n", "/*\r\n  Progress within given range\r\n\r\n  Given a lower limit and an upper limit, we return the progress\r\n  (expressed as a number 0-1) represented by the given value, and\r\n  limit that progress to within 0-1.\r\n\r\n  @param [number]: Lower limit\r\n  @param [number]: Upper limit\r\n  @param [number]: Value to find progress within given range\r\n  @return [number]: Progress of value within range as expressed 0-1\r\n*/\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst progress = (from, to, value) => {\r\n    const toFromDifference = to - from;\r\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\r\n};\r\n\r\nexport { progress };\r\n", "const clamp = (min, max, v) => {\r\n    if (v > max)\r\n        return max;\r\n    if (v < min)\r\n        return min;\r\n    return v;\r\n};\r\n\r\nexport { clamp };\r\n", "/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\r\n\r\nexport { millisecondsToSeconds, secondsToMilliseconds };\r\n", "const springDefaults = {\r\n    // Default spring physics\r\n    stiffness: 100,\r\n    damping: 10,\r\n    mass: 1.0,\r\n    velocity: 0.0,\r\n    // Default duration/bounce-based options\r\n    duration: 800, // in ms\r\n    bounce: 0.3,\r\n    visualDuration: 0.3, // in seconds\r\n    // Rest thresholds\r\n    restSpeed: {\r\n        granular: 0.01,\r\n        default: 2,\r\n    },\r\n    restDelta: {\r\n        granular: 0.005,\r\n        default: 0.5,\r\n    },\r\n    // Limits\r\n    minDuration: 0.01, // in seconds\r\n    maxDuration: 10.0, // in seconds\r\n    minDamping: 0.05,\r\n    maxDamping: 1,\r\n};\r\n\r\nexport { springDefaults };\r\n", "import { warning } from '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\n\r\nconst safeMin = 0.001;\r\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\r\n    let envelope;\r\n    let derivative;\r\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\r\n    let dampingRatio = 1 - bounce;\r\n    /**\r\n     * Restrict dampingRatio and duration to within acceptable ranges.\r\n     */\r\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\r\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\r\n    if (dampingRatio < 1) {\r\n        /**\r\n         * Underdamped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const a = exponentialDecay - velocity;\r\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\r\n            const c = Math.exp(-delta);\r\n            return safeMin - (a / b) * c;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const d = delta * velocity + velocity;\r\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\r\n            const f = Math.exp(-delta);\r\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\r\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\r\n            return (factor * ((d - e) * f)) / g;\r\n        };\r\n    }\r\n    else {\r\n        /**\r\n         * Critically-damped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (undampedFreq - velocity) * duration + 1;\r\n            return -safeMin + a * b;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (velocity - undampedFreq) * (duration * duration);\r\n            return a * b;\r\n        };\r\n    }\r\n    const initialGuess = 5 / duration;\r\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\r\n    duration = secondsToMilliseconds(duration);\r\n    if (isNaN(undampedFreq)) {\r\n        return {\r\n            stiffness: springDefaults.stiffness,\r\n            damping: springDefaults.damping,\r\n            duration,\r\n        };\r\n    }\r\n    else {\r\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\r\n        return {\r\n            stiffness,\r\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\r\n            duration,\r\n        };\r\n    }\r\n}\r\nconst rootIterations = 12;\r\nfunction approximateRoot(envelope, derivative, initialGuess) {\r\n    let result = initialGuess;\r\n    for (let i = 1; i < rootIterations; i++) {\r\n        result = result - envelope(result) / derivative(result);\r\n    }\r\n    return result;\r\n}\r\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\r\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\r\n}\r\n\r\nexport { calcAngularFreq, findSpring };\r\n", "/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxGeneratorDuration = 20000;\r\nfunction calcGeneratorDuration(generator) {\r\n    let duration = 0;\r\n    const timeStep = 50;\r\n    let state = generator.next(duration);\r\n    while (!state.done && duration < maxGeneratorDuration) {\r\n        duration += timeStep;\r\n        state = generator.next(duration);\r\n    }\r\n    return duration >= maxGeneratorDuration ? Infinity : duration;\r\n}\r\n\r\nexport { calcGeneratorDuration, maxGeneratorDuration };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { progress } from '../../../../../../motion-utils/dist/es/progress.mjs';\r\n\r\nconst generateLinearEasing = (easing, duration, // as milliseconds\r\nresolution = 10 // as milliseconds\r\n) => {\r\n    let points = \"\";\r\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\r\n    for (let i = 0; i < numPoints; i++) {\r\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\r\n    }\r\n    return `linear(${points.substring(0, points.length - 2)})`;\r\n};\r\n\r\nexport { generateLinearEasing };\r\n", "/*\r\n  Convert velocity into velocity per second\r\n\r\n  @param [number]: Unit per frame\r\n  @param [number]: Frame duration in ms\r\n*/\r\nfunction velocityPerSecond(velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n}\r\n\r\nexport { velocityPerSecond };\r\n", "import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\r\n\r\nconst velocitySampleDuration = 5; // ms\r\nfunction calcGeneratorVelocity(resolveValue, t, current) {\r\n    const prevT = Math.max(t - velocitySampleDuration, 0);\r\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\r\n}\r\n\r\nexport { calcGeneratorVelocity };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../../../../../../motion-dom/dist/es/animation/generators/utils/calc-duration.mjs';\r\nimport { generateLinearEasing } from '../../../../../../motion-dom/dist/es/animation/waapi/utils/linear.mjs';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\nimport { findSpring, calcAngularFreq } from './find.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: springDefaults.velocity,\r\n        stiffness: springDefaults.stiffness,\r\n        damping: springDefaults.damping,\r\n        mass: springDefaults.mass,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        if (options.visualDuration) {\r\n            const visualDuration = options.visualDuration;\r\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\r\n            const stiffness = root * root;\r\n            const damping = 2 *\r\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\r\n                Math.sqrt(stiffness);\r\n            springOptions = {\r\n                ...springOptions,\r\n                mass: springDefaults.mass,\r\n                stiffness,\r\n                damping,\r\n            };\r\n        }\r\n        else {\r\n            const derived = findSpring(options);\r\n            springOptions = {\r\n                ...springOptions,\r\n                ...derived,\r\n                mass: springDefaults.mass,\r\n            };\r\n            springOptions.isResolvedFromDuration = true;\r\n        }\r\n    }\r\n    return springOptions;\r\n}\r\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\r\n    const options = typeof optionsOrVisualDuration !== \"object\"\r\n        ? {\r\n            visualDuration: optionsOrVisualDuration,\r\n            keyframes: [0, 1],\r\n            bounce,\r\n        }\r\n        : optionsOrVisualDuration;\r\n    let { restSpeed, restDelta } = options;\r\n    const origin = options.keyframes[0];\r\n    const target = options.keyframes[options.keyframes.length - 1];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\r\n        ...options,\r\n        velocity: -millisecondsToSeconds(options.velocity || 0),\r\n    });\r\n    const initialVelocity = velocity || 0.0;\r\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n    const initialDelta = target - origin;\r\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\r\n    /**\r\n     * If we're working on a granular scale, use smaller defaults for determining\r\n     * when the spring is finished.\r\n     *\r\n     * These defaults have been selected emprically based on what strikes a good\r\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n     */\r\n    const isGranularScale = Math.abs(initialDelta) < 5;\r\n    restSpeed || (restSpeed = isGranularScale\r\n        ? springDefaults.restSpeed.granular\r\n        : springDefaults.restSpeed.default);\r\n    restDelta || (restDelta = isGranularScale\r\n        ? springDefaults.restDelta.granular\r\n        : springDefaults.restDelta.default);\r\n    let resolveSpring;\r\n    if (dampingRatio < 1) {\r\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n        // Underdamped spring\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            return (target -\r\n                envelope *\r\n                    (((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) /\r\n                        angularFreq) *\r\n                        Math.sin(angularFreq * t) +\r\n                        initialDelta * Math.cos(angularFreq * t)));\r\n        };\r\n    }\r\n    else if (dampingRatio === 1) {\r\n        // Critically damped spring\r\n        resolveSpring = (t) => target -\r\n            Math.exp(-undampedAngularFreq * t) *\r\n                (initialDelta +\r\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\r\n    }\r\n    else {\r\n        // Overdamped spring\r\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            // When performing sinh or cosh values can hit Infinity so we cap them here\r\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n            return (target -\r\n                (envelope *\r\n                    ((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) *\r\n                        Math.sinh(freqForT) +\r\n                        dampedAngularFreq *\r\n                            initialDelta *\r\n                            Math.cosh(freqForT))) /\r\n                    dampedAngularFreq);\r\n        };\r\n    }\r\n    const generator = {\r\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                let currentVelocity = 0.0;\r\n                /**\r\n                 * We only need to calculate velocity for under-damped springs\r\n                 * as over- and critically-damped springs can't overshoot, so\r\n                 * checking only for displacement is enough.\r\n                 */\r\n                if (dampingRatio < 1) {\r\n                    currentVelocity =\r\n                        t === 0\r\n                            ? secondsToMilliseconds(initialVelocity)\r\n                            : calcGeneratorVelocity(resolveSpring, t, current);\r\n                }\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? target : current;\r\n            return state;\r\n        },\r\n        toString: () => {\r\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\r\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\r\n            return calculatedDuration + \"ms \" + easing;\r\n        },\r\n    };\r\n    return generator;\r\n}\r\n\r\nexport { spring };\r\n", "const wrap = (min, max, v) => {\r\n    const rangeSize = max - min;\r\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\r\n};\r\n\r\nexport { wrap };\r\n", "const isMotionValue = (value) => Boolean(value && value.getVelocity);\r\n\r\nexport { isMotionValue };\r\n", "const visualElementStore = new WeakMap();\r\n\r\nexport { visualElementStore };\r\n", "const MotionGlobalConfig = {\r\n    skipAnimations: false,\r\n    useManualTiming: false,\r\n};\r\n\r\nexport { MotionGlobalConfig };\r\n", "const stepsOrder = [\r\n    \"read\", // Read\r\n    \"resolveKeyframes\", // Write/Read/Write/Read\r\n    \"update\", // Compute\r\n    \"preRender\", // Compute\r\n    \"render\", // Write\r\n    \"postRender\", // Compute\r\n];\r\n\r\nexport { stepsOrder };\r\n", "const statsBuffer = {\r\n    value: null,\r\n    addProjectionMetrics: null,\r\n};\r\n\r\nexport { statsBuffer };\r\n", "import { statsBuffer } from '../stats/buffer.mjs';\r\n\r\nfunction createRenderStep(runNextFrame, stepName) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Set();\r\n    let nextFrame = new Set();\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    let latestFrameData = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    let numCalls = 0;\r\n    function triggerCallback(callback) {\r\n        if (toKeepAlive.has(callback)) {\r\n            step.schedule(callback);\r\n            runNextFrame();\r\n        }\r\n        numCalls++;\r\n        callback(latestFrameData);\r\n    }\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (!queue.has(callback))\r\n                queue.add(callback);\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.delete(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            latestFrameData = frameData;\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Execute this frame\r\n            thisFrame.forEach(triggerCallback);\r\n            /**\r\n             * If we're recording stats then\r\n             */\r\n            if (stepName && statsBuffer.value) {\r\n                statsBuffer.value.frameloop[stepName].push(numCalls);\r\n            }\r\n            numCalls = 0;\r\n            // Clear the frame so no callbacks remain. This is to avoid\r\n            // memory leaks should this render step not run for a while.\r\n            thisFrame.clear();\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n", "import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { stepsOrder } from './order.mjs';\r\nimport { createRenderStep } from './render-step.mjs';\r\n\r\nconst maxElapsed = 40;\r\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\r\n    let runNextFrame = false;\r\n    let useDefaultElapsed = true;\r\n    const state = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    const flagRunNextFrame = () => (runNextFrame = true);\r\n    const steps = stepsOrder.reduce((acc, key) => {\r\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\r\n        return acc;\r\n    }, {});\r\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\r\n    const processBatch = () => {\r\n        const timestamp = MotionGlobalConfig.useManualTiming\r\n            ? state.timestamp\r\n            : performance.now();\r\n        runNextFrame = false;\r\n        if (!MotionGlobalConfig.useManualTiming) {\r\n            state.delta = useDefaultElapsed\r\n                ? 1000 / 60\r\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\r\n        }\r\n        state.timestamp = timestamp;\r\n        state.isProcessing = true;\r\n        // Unrolled render loop for better per-frame performance\r\n        read.process(state);\r\n        resolveKeyframes.process(state);\r\n        update.process(state);\r\n        preRender.process(state);\r\n        render.process(state);\r\n        postRender.process(state);\r\n        state.isProcessing = false;\r\n        if (runNextFrame && allowKeepAlive) {\r\n            useDefaultElapsed = false;\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const wake = () => {\r\n        runNextFrame = true;\r\n        useDefaultElapsed = true;\r\n        if (!state.isProcessing) {\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const schedule = stepsOrder.reduce((acc, key) => {\r\n        const step = steps[key];\r\n        acc[key] = (process, keepAlive = false, immediate = false) => {\r\n            if (!runNextFrame)\r\n                wake();\r\n            return step.schedule(process, keepAlive, immediate);\r\n        };\r\n        return acc;\r\n    }, {});\r\n    const cancel = (process) => {\r\n        for (let i = 0; i < stepsOrder.length; i++) {\r\n            steps[stepsOrder[i]].cancel(process);\r\n        }\r\n    };\r\n    return { schedule, cancel, state, steps };\r\n}\r\n\r\nexport { createRenderBatcher };\r\n", "import '../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../motion-utils/dist/es/noop.mjs';\r\nimport { createRenderBatcher } from './batcher.mjs';\r\n\r\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\r\n\r\nexport { cancelFrame, frame, frameData, frameSteps };\r\n", "import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { frameData } from './frame.mjs';\r\n\r\nlet now;\r\nfunction clearTime() {\r\n    now = undefined;\r\n}\r\n/**\r\n * An eventloop-synchronous alternative to performance.now().\r\n *\r\n * Ensures that time measurements remain consistent within a synchronous context.\r\n * Usually calling performance.now() twice within the same synchronous context\r\n * will return different values which isn't useful for animations when we're usually\r\n * trying to sync animations to the same frame.\r\n */\r\nconst time = {\r\n    now: () => {\r\n        if (now === undefined) {\r\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\r\n                ? frameData.timestamp\r\n                : performance.now());\r\n        }\r\n        return now;\r\n    },\r\n    set: (newTime) => {\r\n        now = newTime;\r\n        queueMicrotask(clearTime);\r\n    },\r\n};\r\n\r\nexport { time };\r\n", "function addUniqueItem(arr, item) {\r\n    if (arr.indexOf(item) === -1)\r\n        arr.push(item);\r\n}\r\nfunction removeItem(arr, item) {\r\n    const index = arr.indexOf(item);\r\n    if (index > -1)\r\n        arr.splice(index, 1);\r\n}\r\n// Adapted from array-move\r\nfunction moveItem([...arr], fromIndex, toIndex) {\r\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\r\n    if (startIndex >= 0 && startIndex < arr.length) {\r\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\r\n        const [item] = arr.splice(fromIndex, 1);\r\n        arr.splice(endIndex, 0, item);\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport { addUniqueItem, moveItem, removeItem };\r\n", "import { addUniqueItem, removeItem } from './array.mjs';\r\n\r\nclass SubscriptionManager {\r\n    constructor() {\r\n        this.subscriptions = [];\r\n    }\r\n    add(handler) {\r\n        addUniqueItem(this.subscriptions, handler);\r\n        return () => removeItem(this.subscriptions, handler);\r\n    }\r\n    notify(a, b, c) {\r\n        const numSubscriptions = this.subscriptions.length;\r\n        if (!numSubscriptions)\r\n            return;\r\n        if (numSubscriptions === 1) {\r\n            /**\r\n             * If there's only a single handler we can just call it without invoking a loop.\r\n             */\r\n            this.subscriptions[0](a, b, c);\r\n        }\r\n        else {\r\n            for (let i = 0; i < numSubscriptions; i++) {\r\n                /**\r\n                 * Check whether the handler exists before firing as it's possible\r\n                 * the subscriptions were modified during this loop running.\r\n                 */\r\n                const handler = this.subscriptions[i];\r\n                handler && handler(a, b, c);\r\n            }\r\n        }\r\n    }\r\n    getSize() {\r\n        return this.subscriptions.length;\r\n    }\r\n    clear() {\r\n        this.subscriptions.length = 0;\r\n    }\r\n}\r\n\r\nexport { SubscriptionManager };\r\n", "const warned = new Set();\r\nfunction warnOnce(condition, message, element) {\r\n    if (condition || warned.has(message))\r\n        return;\r\n    console.warn(message);\r\n    if (element)\r\n        console.warn(element);\r\n    warned.add(message);\r\n}\r\n\r\nexport { warnOnce };\r\n", "import { time } from '../frameloop/sync-time.mjs';\r\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\r\nimport { velocityPerSecond } from '../utils/velocity-per-second.mjs';\r\nimport { warnOnce } from '../utils/warn-once.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\n/**\r\n * Maximum time between the value of two frames, beyond which we\r\n * assume the velocity has since been 0.\r\n */\r\nconst MAX_VELOCITY_DELTA = 30;\r\nconst isFloat = (value) => {\r\n    return !isNaN(parseFloat(value));\r\n};\r\nconst collectMotionValues = {\r\n    current: undefined,\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nclass MotionValue {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    constructor(init, options = {}) {\r\n        /**\r\n         * This will be replaced by the build step with the latest version number.\r\n         * When MotionValues are provided to motion components, warn if versions are mixed.\r\n         */\r\n        this.version = \"12.4.7\";\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = null;\r\n        /**\r\n         * An object containing a SubscriptionManager for each active event.\r\n         */\r\n        this.events = {};\r\n        this.updateAndNotify = (v, render = true) => {\r\n            const currentTime = time.now();\r\n            /**\r\n             * If we're updating the value during another frame or eventloop\r\n             * than the previous frame, then the we set the previous frame value\r\n             * to current.\r\n             */\r\n            if (this.updatedAt !== currentTime) {\r\n                this.setPrevFrameValue();\r\n            }\r\n            this.prev = this.current;\r\n            this.setCurrent(v);\r\n            // Update update subscribers\r\n            if (this.current !== this.prev && this.events.change) {\r\n                this.events.change.notify(this.current);\r\n            }\r\n            // Update render subscribers\r\n            if (render && this.events.renderRequest) {\r\n                this.events.renderRequest.notify(this.current);\r\n            }\r\n        };\r\n        this.hasAnimated = false;\r\n        this.setCurrent(init);\r\n        this.owner = options.owner;\r\n    }\r\n    setCurrent(current) {\r\n        this.current = current;\r\n        this.updatedAt = time.now();\r\n        if (this.canTrackVelocity === null && current !== undefined) {\r\n            this.canTrackVelocity = isFloat(this.current);\r\n        }\r\n    }\r\n    setPrevFrameValue(prevFrameValue = this.current) {\r\n        this.prevFrameValue = prevFrameValue;\r\n        this.prevUpdatedAt = this.updatedAt;\r\n    }\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\r\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @deprecated\r\n     */\r\n    onChange(subscription) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\r\n        }\r\n        return this.on(\"change\", subscription);\r\n    }\r\n    on(eventName, callback) {\r\n        if (!this.events[eventName]) {\r\n            this.events[eventName] = new SubscriptionManager();\r\n        }\r\n        const unsubscribe = this.events[eventName].add(callback);\r\n        if (eventName === \"change\") {\r\n            return () => {\r\n                unsubscribe();\r\n                /**\r\n                 * If we have no more change listeners by the start\r\n                 * of the next frame, stop active animations.\r\n                 */\r\n                frame.read(() => {\r\n                    if (!this.events.change.getSize()) {\r\n                        this.stop();\r\n                    }\r\n                });\r\n            };\r\n        }\r\n        return unsubscribe;\r\n    }\r\n    clearListeners() {\r\n        for (const eventManagers in this.events) {\r\n            this.events[eventManagers].clear();\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    attach(passiveEffect, stopPassiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n        this.stopPassiveEffect = stopPassiveEffect;\r\n    }\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    set(v, render = true) {\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    }\r\n    setWithVelocity(prev, current, delta) {\r\n        this.set(current);\r\n        this.prev = undefined;\r\n        this.prevFrameValue = prev;\r\n        this.prevUpdatedAt = this.updatedAt - delta;\r\n    }\r\n    /**\r\n     * Set the state of the `MotionValue`, stopping any active animations,\r\n     * effects, and resets velocity to `0`.\r\n     */\r\n    jump(v, endAnimation = true) {\r\n        this.updateAndNotify(v);\r\n        this.prev = v;\r\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\r\n        endAnimation && this.stop();\r\n        if (this.stopPassiveEffect)\r\n            this.stopPassiveEffect();\r\n    }\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    get() {\r\n        if (collectMotionValues.current) {\r\n            collectMotionValues.current.push(this);\r\n        }\r\n        return this.current;\r\n    }\r\n    /**\r\n     * @public\r\n     */\r\n    getPrevious() {\r\n        return this.prev;\r\n    }\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    getVelocity() {\r\n        const currentTime = time.now();\r\n        if (!this.canTrackVelocity ||\r\n            this.prevFrameValue === undefined ||\r\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\r\n            return 0;\r\n        }\r\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\r\n        // Casts because of parseFloat's poor typing\r\n        return velocityPerSecond(parseFloat(this.current) -\r\n            parseFloat(this.prevFrameValue), delta);\r\n    }\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    start(startAnimation) {\r\n        this.stop();\r\n        return new Promise((resolve) => {\r\n            this.hasAnimated = true;\r\n            this.animation = startAnimation(resolve);\r\n            if (this.events.animationStart) {\r\n                this.events.animationStart.notify();\r\n            }\r\n        }).then(() => {\r\n            if (this.events.animationComplete) {\r\n                this.events.animationComplete.notify();\r\n            }\r\n            this.clearAnimation();\r\n        });\r\n    }\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    stop() {\r\n        if (this.animation) {\r\n            this.animation.stop();\r\n            if (this.events.animationCancel) {\r\n                this.events.animationCancel.notify();\r\n            }\r\n        }\r\n        this.clearAnimation();\r\n    }\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    isAnimating() {\r\n        return !!this.animation;\r\n    }\r\n    clearAnimation() {\r\n        delete this.animation;\r\n    }\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    destroy() {\r\n        this.clearListeners();\r\n        this.stop();\r\n        if (this.stopPassiveEffect) {\r\n            this.stopPassiveEffect();\r\n        }\r\n    }\r\n}\r\nfunction motionValue(init, options) {\r\n    return new MotionValue(init, options);\r\n}\r\n\r\nexport { MotionValue, collectMotionValues, motionValue };\r\n", "/**\r\n * Convert camelCase to dash-case properties.\r\n */\r\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\r\n\r\nexport { camelToDash };\r\n", "import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\r\n\r\nconst optimizedAppearDataId = \"framerAppearId\";\r\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\r\n\r\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\r\n", "import '../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../motion-utils/dist/es/noop.mjs';\r\n\r\n/*\r\n  Bezier function generator\r\n  This has been modified from Gatan Renaudeau's BezierEasing\r\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\r\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\r\n  \r\n  I've removed the newtonRaphsonIterate algo because in benchmarking it\r\n  wasn't noticiably faster than binarySubdivision, indeed removing it\r\n  usually improved times, depending on the curve.\r\n  I also removed the lookup table, as for the added bundle size and loop we're\r\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\r\n  to 12 to compensate and this still tended to be faster for no perceivable\r\n  loss in accuracy.\r\n  Usage\r\n    const easeOut = cubicBezier(.17,.67,.83,.67);\r\n    const x = easeOut(0.5); // returns 0.627...\r\n*/\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\r\n    t;\r\nconst subdivisionPrecision = 0.0000001;\r\nconst subdivisionMaxIterations = 12;\r\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\r\n    let currentX;\r\n    let currentT;\r\n    let i = 0;\r\n    do {\r\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\r\n        currentX = calcBezier(currentT, mX1, mX2) - x;\r\n        if (currentX > 0.0) {\r\n            upperBound = currentT;\r\n        }\r\n        else {\r\n            lowerBound = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > subdivisionPrecision &&\r\n        ++i < subdivisionMaxIterations);\r\n    return currentT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    // If this is a linear gradient, return linear easing\r\n    if (mX1 === mY1 && mX2 === mY2)\r\n        return noop;\r\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\r\n    // If animation is at start/end, return t without easing\r\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\r\n}\r\n\r\nexport { cubicBezier };\r\n", "// Accepts an easing function and returns a new one that outputs mirrored values for\r\n// the second half of the animation. Turns easeIn into easeInOut.\r\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\r\n\r\nexport { mirrorEasing };\r\n", "// Accepts an easing function and returns a new one that outputs reversed values.\r\n// Turns easeIn into easeOut.\r\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\r\n\r\nexport { reverseEasing };\r\n", "import { cubicBezier } from './cubic-bezier.mjs';\r\nimport { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\r\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\r\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\r\n\r\nexport { backIn, backInOut, backOut };\r\n", "import { backIn } from './back.mjs';\r\n\r\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\r\n\r\nexport { anticipate };\r\n", "import { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\r\nconst circOut = reverseEasing(circIn);\r\nconst circInOut = mirrorEasing(circIn);\r\n\r\nexport { circIn, circInOut, circOut };\r\n", "const createUnitType = (unit) => ({\r\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\r\n    parse: parseFloat,\r\n    transform: (v) => `${v}${unit}`,\r\n});\r\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\r\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\r\nconst px = /*@__PURE__*/ createUnitType(\"px\");\r\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\r\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\r\nconst progressPercentage = {\r\n    ...percent,\r\n    parse: (v) => percent.parse(v) / 100,\r\n    transform: (v) => percent.transform(v * 100),\r\n};\r\n\r\nexport { degrees, percent, progressPercentage, px, vh, vw };\r\n", "import { clamp } from '../../../utils/clamp.mjs';\r\n\r\nconst number = {\r\n    test: (v) => typeof v === \"number\",\r\n    parse: parseFloat,\r\n    transform: (v) => v,\r\n};\r\nconst alpha = {\r\n    ...number,\r\n    transform: (v) => clamp(0, 1, v),\r\n};\r\nconst scale = {\r\n    ...number,\r\n    default: 1,\r\n};\r\n\r\nexport { alpha, number, scale };\r\n", "// If this number is a decimal, make it just five decimal places\r\n// to avoid exponents\r\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\r\n\r\nexport { sanitize };\r\n", "const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\r\n\r\nexport { floatRegex };\r\n", "function isNullish(v) {\r\n    return v == null;\r\n}\r\n\r\nexport { isNullish };\r\n", "const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\r\n\r\nexport { singleColorRegex };\r\n", "import { floatRegex } from '../utils/float-regex.mjs';\r\nimport { isNullish } from '../utils/is-nullish.mjs';\r\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\r\n\r\n/**\r\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\r\n * but false if a number or multiple colors\r\n */\r\nconst isColorString = (type, testProp) => (v) => {\r\n    return Boolean((typeof v === \"string\" &&\r\n        singleColorRegex.test(v) &&\r\n        v.startsWith(type)) ||\r\n        (testProp &&\r\n            !isNullish(v) &&\r\n            Object.prototype.hasOwnProperty.call(v, testProp)));\r\n};\r\nconst splitColor = (aName, bName, cName) => (v) => {\r\n    if (typeof v !== \"string\")\r\n        return v;\r\n    const [a, b, c, alpha] = v.match(floatRegex);\r\n    return {\r\n        [aName]: parseFloat(a),\r\n        [bName]: parseFloat(b),\r\n        [cName]: parseFloat(c),\r\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\r\n    };\r\n};\r\n\r\nexport { isColorString, splitColor };\r\n", "import { clamp } from '../../../utils/clamp.mjs';\r\nimport { alpha, number } from '../numbers/index.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\nimport { isColorString, splitColor } from './utils.mjs';\r\n\r\nconst clampRgbUnit = (v) => clamp(0, 255, v);\r\nconst rgbUnit = {\r\n    ...number,\r\n    transform: (v) => Math.round(clampRgbUnit(v)),\r\n};\r\nconst rgba = {\r\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\r\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\r\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\r\n        rgbUnit.transform(red) +\r\n        \", \" +\r\n        rgbUnit.transform(green) +\r\n        \", \" +\r\n        rgbUnit.transform(blue) +\r\n        \", \" +\r\n        sanitize(alpha.transform(alpha$1)) +\r\n        \")\",\r\n};\r\n\r\nexport { rgbUnit, rgba };\r\n", "import { rgba } from './rgba.mjs';\r\nimport { isColorString } from './utils.mjs';\r\n\r\nfunction parseHex(v) {\r\n    let r = \"\";\r\n    let g = \"\";\r\n    let b = \"\";\r\n    let a = \"\";\r\n    // If we have 6 characters, ie #FF0000\r\n    if (v.length > 5) {\r\n        r = v.substring(1, 3);\r\n        g = v.substring(3, 5);\r\n        b = v.substring(5, 7);\r\n        a = v.substring(7, 9);\r\n        // Or we have 3 characters, ie #F00\r\n    }\r\n    else {\r\n        r = v.substring(1, 2);\r\n        g = v.substring(2, 3);\r\n        b = v.substring(3, 4);\r\n        a = v.substring(4, 5);\r\n        r += r;\r\n        g += g;\r\n        b += b;\r\n        a += a;\r\n    }\r\n    return {\r\n        red: parseInt(r, 16),\r\n        green: parseInt(g, 16),\r\n        blue: parseInt(b, 16),\r\n        alpha: a ? parseInt(a, 16) / 255 : 1,\r\n    };\r\n}\r\nconst hex = {\r\n    test: /*@__PURE__*/ isColorString(\"#\"),\r\n    parse: parseHex,\r\n    transform: rgba.transform,\r\n};\r\n\r\nexport { hex };\r\n", "import { alpha } from '../numbers/index.mjs';\r\nimport { percent } from '../numbers/units.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\nimport { isColorString, splitColor } from './utils.mjs';\r\n\r\nconst hsla = {\r\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\r\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\r\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\r\n        return (\"hsla(\" +\r\n            Math.round(hue) +\r\n            \", \" +\r\n            percent.transform(sanitize(saturation)) +\r\n            \", \" +\r\n            percent.transform(sanitize(lightness)) +\r\n            \", \" +\r\n            sanitize(alpha.transform(alpha$1)) +\r\n            \")\");\r\n    },\r\n};\r\n\r\nexport { hsla };\r\n", "import { hex } from './hex.mjs';\r\nimport { hsla } from './hsla.mjs';\r\nimport { rgba } from './rgba.mjs';\r\n\r\nconst color = {\r\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\r\n    parse: (v) => {\r\n        if (rgba.test(v)) {\r\n            return rgba.parse(v);\r\n        }\r\n        else if (hsla.test(v)) {\r\n            return hsla.parse(v);\r\n        }\r\n        else {\r\n            return hex.parse(v);\r\n        }\r\n    },\r\n    transform: (v) => {\r\n        return typeof v === \"string\"\r\n            ? v\r\n            : v.hasOwnProperty(\"red\")\r\n                ? rgba.transform(v)\r\n                : hsla.transform(v);\r\n    },\r\n};\r\n\r\nexport { color };\r\n", "const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\r\n\r\nexport { colorRegex };\r\n", "import { color } from '../color/index.mjs';\r\nimport { colorRegex } from '../utils/color-regex.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\n\r\nfunction test(v) {\r\n    var _a, _b;\r\n    return (isNaN(v) &&\r\n        typeof v === \"string\" &&\r\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\r\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\r\n            0);\r\n}\r\nconst NUMBER_TOKEN = \"number\";\r\nconst COLOR_TOKEN = \"color\";\r\nconst VAR_TOKEN = \"var\";\r\nconst VAR_FUNCTION_TOKEN = \"var(\";\r\nconst SPLIT_TOKEN = \"${}\";\r\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\r\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\r\nfunction analyseComplexValue(value) {\r\n    const originalValue = value.toString();\r\n    const values = [];\r\n    const indexes = {\r\n        color: [],\r\n        number: [],\r\n        var: [],\r\n    };\r\n    const types = [];\r\n    let i = 0;\r\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\r\n        if (color.test(parsedValue)) {\r\n            indexes.color.push(i);\r\n            types.push(COLOR_TOKEN);\r\n            values.push(color.parse(parsedValue));\r\n        }\r\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\r\n            indexes.var.push(i);\r\n            types.push(VAR_TOKEN);\r\n            values.push(parsedValue);\r\n        }\r\n        else {\r\n            indexes.number.push(i);\r\n            types.push(NUMBER_TOKEN);\r\n            values.push(parseFloat(parsedValue));\r\n        }\r\n        ++i;\r\n        return SPLIT_TOKEN;\r\n    });\r\n    const split = tokenised.split(SPLIT_TOKEN);\r\n    return { values, split, indexes, types };\r\n}\r\nfunction parseComplexValue(v) {\r\n    return analyseComplexValue(v).values;\r\n}\r\nfunction createTransformer(source) {\r\n    const { split, types } = analyseComplexValue(source);\r\n    const numSections = split.length;\r\n    return (v) => {\r\n        let output = \"\";\r\n        for (let i = 0; i < numSections; i++) {\r\n            output += split[i];\r\n            if (v[i] !== undefined) {\r\n                const type = types[i];\r\n                if (type === NUMBER_TOKEN) {\r\n                    output += sanitize(v[i]);\r\n                }\r\n                else if (type === COLOR_TOKEN) {\r\n                    output += color.transform(v[i]);\r\n                }\r\n                else {\r\n                    output += v[i];\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n}\r\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\r\nfunction getAnimatableNone(v) {\r\n    const parsed = parseComplexValue(v);\r\n    const transformer = createTransformer(v);\r\n    return transformer(parsed.map(convertNumbersToZero));\r\n}\r\nconst complex = {\r\n    test,\r\n    parse: parseComplexValue,\r\n    createTransformer,\r\n    getAnimatableNone,\r\n};\r\n\r\nexport { analyseComplexValue, complex };\r\n", "/**\r\n * Pipe\r\n * Compose other transformers to run linearily\r\n * pipe(min(20), max(40))\r\n * @param  {...functions} transformers\r\n * @return {function}\r\n */\r\nconst combineFunctions = (a, b) => (v) => b(a(v));\r\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\r\n\r\nexport { pipe };\r\n", "/*\r\n  Value in range from progress\r\n\r\n  Given a lower limit and an upper limit, we return the value within\r\n  that range as expressed by progress (usually a number from 0 to 1)\r\n\r\n  So progress = 0.5 would change\r\n\r\n  from -------- to\r\n\r\n  to\r\n\r\n  from ---- to\r\n\r\n  E.g. from = 10, to = 20, progress = 0.5 => 15\r\n\r\n  @param [number]: Lower limit of range\r\n  @param [number]: Upper limit of range\r\n  @param [number]: The progress between lower and upper limits expressed 0-1\r\n  @return [number]: Value as calculated from progress within range (not limited within range)\r\n*/\r\nconst mixNumber = (from, to, progress) => {\r\n    return from + (to - from) * progress;\r\n};\r\n\r\nexport { mixNumber };\r\n", "// Adapted from https://gist.github.com/mjackson/5311256\r\nfunction hueToRgb(p, q, t) {\r\n    if (t < 0)\r\n        t += 1;\r\n    if (t > 1)\r\n        t -= 1;\r\n    if (t < 1 / 6)\r\n        return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2)\r\n        return q;\r\n    if (t < 2 / 3)\r\n        return p + (q - p) * (2 / 3 - t) * 6;\r\n    return p;\r\n}\r\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\r\n    hue /= 360;\r\n    saturation /= 100;\r\n    lightness /= 100;\r\n    let red = 0;\r\n    let green = 0;\r\n    let blue = 0;\r\n    if (!saturation) {\r\n        red = green = blue = lightness;\r\n    }\r\n    else {\r\n        const q = lightness < 0.5\r\n            ? lightness * (1 + saturation)\r\n            : lightness + saturation - lightness * saturation;\r\n        const p = 2 * lightness - q;\r\n        red = hueToRgb(p, q, hue + 1 / 3);\r\n        green = hueToRgb(p, q, hue);\r\n        blue = hueToRgb(p, q, hue - 1 / 3);\r\n    }\r\n    return {\r\n        red: Math.round(red * 255),\r\n        green: Math.round(green * 255),\r\n        blue: Math.round(blue * 255),\r\n        alpha,\r\n    };\r\n}\r\n\r\nexport { hslaToRgba };\r\n", "function mixImmediate(a, b) {\r\n    return (p) => (p > 0 ? b : a);\r\n}\r\n\r\nexport { mixImmediate };\r\n", "import { mixNumber } from './number.mjs';\r\nimport { warning } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { hslaToRgba } from '../hsla-to-rgba.mjs';\r\nimport { hex } from '../../value/types/color/hex.mjs';\r\nimport { rgba } from '../../value/types/color/rgba.mjs';\r\nimport { hsla } from '../../value/types/color/hsla.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\n// Linear color space blending\r\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\r\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\r\nconst mixLinearColor = (from, to, v) => {\r\n    const fromExpo = from * from;\r\n    const expo = v * (to * to - fromExpo) + fromExpo;\r\n    return expo < 0 ? 0 : Math.sqrt(expo);\r\n};\r\nconst colorTypes = [hex, rgba, hsla];\r\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\r\nfunction asRGBA(color) {\r\n    const type = getColorType(color);\r\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\r\n    if (!Boolean(type))\r\n        return false;\r\n    let model = type.parse(color);\r\n    if (type === hsla) {\r\n        // TODO Remove this cast - needed since Motion's stricter typing\r\n        model = hslaToRgba(model);\r\n    }\r\n    return model;\r\n}\r\nconst mixColor = (from, to) => {\r\n    const fromRGBA = asRGBA(from);\r\n    const toRGBA = asRGBA(to);\r\n    if (!fromRGBA || !toRGBA) {\r\n        return mixImmediate(from, to);\r\n    }\r\n    const blended = { ...fromRGBA };\r\n    return (v) => {\r\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\r\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\r\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\r\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\r\n        return rgba.transform(blended);\r\n    };\r\n};\r\n\r\nexport { mixColor, mixLinearColor };\r\n", "const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\r\nconst isCSSVariableName = \r\n/*@__PURE__*/ checkStringStartsWith(\"--\");\r\nconst startsAsVariableToken = \r\n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\r\nconst isCSSVariableToken = (value) => {\r\n    const startsWithToken = startsAsVariableToken(value);\r\n    if (!startsWithToken)\r\n        return false;\r\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\r\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\r\n};\r\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\r\n\r\nexport { isCSSVariableName, isCSSVariableToken };\r\n", "const invisibleValues = new Set([\"none\", \"hidden\"]);\r\n/**\r\n * Returns a function that, when provided a progress value between 0 and 1,\r\n * will return the \"none\" or \"hidden\" string only when the progress is that of\r\n * the origin or target.\r\n */\r\nfunction mixVisibility(origin, target) {\r\n    if (invisibleValues.has(origin)) {\r\n        return (p) => (p <= 0 ? origin : target);\r\n    }\r\n    else {\r\n        return (p) => (p >= 1 ? target : origin);\r\n    }\r\n}\r\n\r\nexport { invisibleValues, mixVisibility };\r\n", "import { mixNumber as mixNumber$1 } from './number.mjs';\r\nimport { mixColor } from './color.mjs';\r\nimport { pipe } from '../pipe.mjs';\r\nimport { warning } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { color } from '../../value/types/color/index.mjs';\r\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\r\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\r\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\nfunction mixNumber(a, b) {\r\n    return (p) => mixNumber$1(a, b, p);\r\n}\r\nfunction getMixer(a) {\r\n    if (typeof a === \"number\") {\r\n        return mixNumber;\r\n    }\r\n    else if (typeof a === \"string\") {\r\n        return isCSSVariableToken(a)\r\n            ? mixImmediate\r\n            : color.test(a)\r\n                ? mixColor\r\n                : mixComplex;\r\n    }\r\n    else if (Array.isArray(a)) {\r\n        return mixArray;\r\n    }\r\n    else if (typeof a === \"object\") {\r\n        return color.test(a) ? mixColor : mixObject;\r\n    }\r\n    return mixImmediate;\r\n}\r\nfunction mixArray(a, b) {\r\n    const output = [...a];\r\n    const numValues = output.length;\r\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\r\n    return (p) => {\r\n        for (let i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](p);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction mixObject(a, b) {\r\n    const output = { ...a, ...b };\r\n    const blendValue = {};\r\n    for (const key in output) {\r\n        if (a[key] !== undefined && b[key] !== undefined) {\r\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\r\n        }\r\n    }\r\n    return (v) => {\r\n        for (const key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction matchOrder(origin, target) {\r\n    var _a;\r\n    const orderedOrigin = [];\r\n    const pointers = { color: 0, var: 0, number: 0 };\r\n    for (let i = 0; i < target.values.length; i++) {\r\n        const type = target.types[i];\r\n        const originIndex = origin.indexes[type][pointers[type]];\r\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\r\n        orderedOrigin[i] = originValue;\r\n        pointers[type]++;\r\n    }\r\n    return orderedOrigin;\r\n}\r\nconst mixComplex = (origin, target) => {\r\n    const template = complex.createTransformer(target);\r\n    const originStats = analyseComplexValue(origin);\r\n    const targetStats = analyseComplexValue(target);\r\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\r\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\r\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\r\n    if (canInterpolate) {\r\n        if ((invisibleValues.has(origin) &&\r\n            !targetStats.values.length) ||\r\n            (invisibleValues.has(target) &&\r\n                !originStats.values.length)) {\r\n            return mixVisibility(origin, target);\r\n        }\r\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\r\n    }\r\n    else {\r\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\r\n        return mixImmediate(origin, target);\r\n    }\r\n};\r\n\r\nexport { getMixer, mixArray, mixComplex, mixObject };\r\n", "import { getMixer } from './complex.mjs';\r\nimport { mixNumber } from './number.mjs';\r\n\r\nfunction mix(from, to, p) {\r\n    if (typeof from === \"number\" &&\r\n        typeof to === \"number\" &&\r\n        typeof p === \"number\") {\r\n        return mixNumber(from, to, p);\r\n    }\r\n    const mixer = getMixer(from);\r\n    return mixer(from, to);\r\n}\r\n\r\nexport { mix };\r\n", "import { spring } from './spring/index.mjs';\r\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\r\n\r\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\r\n    const origin = keyframes[0];\r\n    const state = {\r\n        done: false,\r\n        value: origin,\r\n    };\r\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\r\n    const nearestBoundary = (v) => {\r\n        if (min === undefined)\r\n            return max;\r\n        if (max === undefined)\r\n            return min;\r\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\r\n    };\r\n    let amplitude = power * velocity;\r\n    const ideal = origin + amplitude;\r\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - origin;\r\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\r\n    const calcLatest = (t) => target + calcDelta(t);\r\n    const applyFriction = (t) => {\r\n        const delta = calcDelta(t);\r\n        const latest = calcLatest(t);\r\n        state.done = Math.abs(delta) <= restDelta;\r\n        state.value = state.done ? target : latest;\r\n    };\r\n    /**\r\n     * Ideally this would resolve for t in a stateless way, we could\r\n     * do that by always precalculating the animation but as we know\r\n     * this will be done anyway we can assume that spring will\r\n     * be discovered during that.\r\n     */\r\n    let timeReachedBoundary;\r\n    let spring$1;\r\n    const checkCatchBoundary = (t) => {\r\n        if (!isOutOfBounds(state.value))\r\n            return;\r\n        timeReachedBoundary = t;\r\n        spring$1 = spring({\r\n            keyframes: [state.value, nearestBoundary(state.value)],\r\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\r\n            damping: bounceDamping,\r\n            stiffness: bounceStiffness,\r\n            restDelta,\r\n            restSpeed,\r\n        });\r\n    };\r\n    checkCatchBoundary(0);\r\n    return {\r\n        calculatedDuration: null,\r\n        next: (t) => {\r\n            /**\r\n             * We need to resolve the friction to figure out if we need a\r\n             * spring but we don't want to do this twice per frame. So here\r\n             * we flag if we updated for this frame and later if we did\r\n             * we can skip doing it again.\r\n             */\r\n            let hasUpdatedFrame = false;\r\n            if (!spring$1 && timeReachedBoundary === undefined) {\r\n                hasUpdatedFrame = true;\r\n                applyFriction(t);\r\n                checkCatchBoundary(t);\r\n            }\r\n            /**\r\n             * If we have a spring and the provided t is beyond the moment the friction\r\n             * animation crossed the min/max boundary, use the spring.\r\n             */\r\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\r\n                return spring$1.next(t - timeReachedBoundary);\r\n            }\r\n            else {\r\n                !hasUpdatedFrame && applyFriction(t);\r\n                return state;\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nexport { inertia };\r\n", "import { cubicBezier } from './cubic-bezier.mjs';\r\n\r\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\r\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\r\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\r\n\r\nexport { easeIn, easeInOut, easeOut };\r\n", "import { invariant } from '../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../motion-utils/dist/es/noop.mjs';\r\nimport { progress } from '../../../../motion-utils/dist/es/progress.mjs';\r\nimport { clamp } from './clamp.mjs';\r\nimport { mix } from './mix/index.mjs';\r\nimport { pipe } from './pipe.mjs';\r\n\r\nfunction createMixers(output, ease, customMixer) {\r\n    const mixers = [];\r\n    const mixerFactory = customMixer || mix;\r\n    const numMixers = output.length - 1;\r\n    for (let i = 0; i < numMixers; i++) {\r\n        let mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\r\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\r\n    const inputLength = input.length;\r\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\r\n    /**\r\n     * If we're only provided a single input, we can just make a function\r\n     * that returns the output.\r\n     */\r\n    if (inputLength === 1)\r\n        return () => output[0];\r\n    if (inputLength === 2 && output[0] === output[1])\r\n        return () => output[1];\r\n    const isZeroDeltaRange = input[0] === input[1];\r\n    // If input runs highest -> lowest, reverse both arrays\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [...input].reverse();\r\n        output = [...output].reverse();\r\n    }\r\n    const mixers = createMixers(output, ease, mixer);\r\n    const numMixers = mixers.length;\r\n    const interpolator = (v) => {\r\n        if (isZeroDeltaRange && v < input[0])\r\n            return output[0];\r\n        let i = 0;\r\n        if (numMixers > 1) {\r\n            for (; i < input.length - 2; i++) {\r\n                if (v < input[i + 1])\r\n                    break;\r\n            }\r\n        }\r\n        const progressInRange = progress(input[i], input[i + 1], v);\r\n        return mixers[i](progressInRange);\r\n    };\r\n    return isClamp\r\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\r\n        : interpolator;\r\n}\r\n\r\nexport { interpolate };\r\n", "const isEasingArray = (ease) => {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\r\n\r\nexport { isEasingArray };\r\n", "const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\r\n\r\nexport { isBezierDefinition };\r\n", "import { invariant } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\r\nimport { isBezierDefinition } from '../../../../../motion-dom/dist/es/utils/is-bezier-definition.mjs';\r\nimport { anticipate } from '../anticipate.mjs';\r\nimport { backIn, backInOut, backOut } from '../back.mjs';\r\nimport { circIn, circInOut, circOut } from '../circ.mjs';\r\nimport { cubicBezier } from '../cubic-bezier.mjs';\r\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\r\n\r\nconst easingLookup = {\r\n    linear: noop,\r\n    easeIn,\r\n    easeInOut,\r\n    easeOut,\r\n    circIn,\r\n    circInOut,\r\n    circOut,\r\n    backIn,\r\n    backInOut,\r\n    backOut,\r\n    anticipate,\r\n};\r\nconst easingDefinitionToFunction = (definition) => {\r\n    if (isBezierDefinition(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\r\n        const [x1, y1, x2, y2] = definition;\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\n\r\nexport { easingDefinitionToFunction };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { progress } from '../../../../../motion-utils/dist/es/progress.mjs';\r\nimport { mixNumber } from '../mix/number.mjs';\r\n\r\nfunction fillOffset(offset, remaining) {\r\n    const min = offset[offset.length - 1];\r\n    for (let i = 1; i <= remaining; i++) {\r\n        const offsetProgress = progress(0, remaining, i);\r\n        offset.push(mixNumber(min, 1, offsetProgress));\r\n    }\r\n}\r\n\r\nexport { fillOffset };\r\n", "import { fillOffset } from './fill.mjs';\r\n\r\nfunction defaultOffset(arr) {\r\n    const offset = [0];\r\n    fillOffset(offset, arr.length - 1);\r\n    return offset;\r\n}\r\n\r\nexport { defaultOffset };\r\n", "function convertOffsetToTimes(offset, duration) {\r\n    return offset.map((o) => o * duration);\r\n}\r\n\r\nexport { convertOffsetToTimes };\r\n", "import { easeInOut } from '../../easing/ease.mjs';\r\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\r\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\r\n\r\nfunction defaultEasing(values, easing) {\r\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\r\n}\r\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\r\n    /**\r\n     * Easing functions can be externally defined as strings. Here we convert them\r\n     * into actual functions.\r\n     */\r\n    const easingFunctions = isEasingArray(ease)\r\n        ? ease.map(easingDefinitionToFunction)\r\n        : easingDefinitionToFunction(ease);\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = {\r\n        done: false,\r\n        value: keyframeValues[0],\r\n    };\r\n    /**\r\n     * Create a times array based on the provided 0-1 offsets\r\n     */\r\n    const absoluteTimes = convertOffsetToTimes(\r\n    // Only use the provided offsets if they're the correct length\r\n    // TODO Maybe we should warn here if there's a length mismatch\r\n    times && times.length === keyframeValues.length\r\n        ? times\r\n        : defaultOffset(keyframeValues), duration);\r\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\r\n        ease: Array.isArray(easingFunctions)\r\n            ? easingFunctions\r\n            : defaultEasing(keyframeValues, easingFunctions),\r\n    });\r\n    return {\r\n        calculatedDuration: duration,\r\n        next: (t) => {\r\n            state.value = mapTimeToKeyframe(t);\r\n            state.done = t >= duration;\r\n            return state;\r\n        },\r\n    };\r\n}\r\n\r\nexport { defaultEasing, keyframes };\r\n", "function isGenerator(type) {\r\n    return typeof type === \"function\";\r\n}\r\n\r\nexport { isGenerator };\r\n", "/**\r\n * Generate a list of every possible transform key.\r\n */\r\nconst transformPropOrder = [\r\n    \"transformPerspective\",\r\n    \"x\",\r\n    \"y\",\r\n    \"z\",\r\n    \"translateX\",\r\n    \"translateY\",\r\n    \"translateZ\",\r\n    \"scale\",\r\n    \"scaleX\",\r\n    \"scaleY\",\r\n    \"rotate\",\r\n    \"rotateX\",\r\n    \"rotateY\",\r\n    \"rotateZ\",\r\n    \"skew\",\r\n    \"skewX\",\r\n    \"skewY\",\r\n];\r\n/**\r\n * A quick lookup for transform props.\r\n */\r\nconst transformProps = new Set(transformPropOrder);\r\n\r\nexport { transformPropOrder, transformProps };\r\n", "import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\n\r\nconst isNumOrPxType = (v) => v === number || v === px;\r\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\r\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    const removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    return removedTransforms;\r\n}\r\nconst positionalValues = {\r\n    // Dimensions\r\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\r\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\r\n    top: (_bbox, { top }) => parseFloat(top),\r\n    left: (_bbox, { left }) => parseFloat(left),\r\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\r\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\n// Alias translate longform names\r\npositionalValues.translateX = positionalValues.x;\r\npositionalValues.translateY = positionalValues.y;\r\n\r\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\r\n", "import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst toResolve = new Set();\r\nlet isScheduled = false;\r\nlet anyNeedsMeasurement = false;\r\nfunction measureAllKeyframes() {\r\n    if (anyNeedsMeasurement) {\r\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\r\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\r\n        const transformsToRestore = new Map();\r\n        /**\r\n         * Write pass\r\n         * If we're measuring elements we want to remove bounding box-changing transforms.\r\n         */\r\n        elementsToMeasure.forEach((element) => {\r\n            const removedTransforms = removeNonTranslationalTransform(element);\r\n            if (!removedTransforms.length)\r\n                return;\r\n            transformsToRestore.set(element, removedTransforms);\r\n            element.render();\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\r\n        // Write\r\n        elementsToMeasure.forEach((element) => {\r\n            element.render();\r\n            const restore = transformsToRestore.get(element);\r\n            if (restore) {\r\n                restore.forEach(([key, value]) => {\r\n                    var _a;\r\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\r\n                });\r\n            }\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\r\n        // Write\r\n        resolversToMeasure.forEach((resolver) => {\r\n            if (resolver.suspendedScrollY !== undefined) {\r\n                window.scrollTo(0, resolver.suspendedScrollY);\r\n            }\r\n        });\r\n    }\r\n    anyNeedsMeasurement = false;\r\n    isScheduled = false;\r\n    toResolve.forEach((resolver) => resolver.complete());\r\n    toResolve.clear();\r\n}\r\nfunction readAllKeyframes() {\r\n    toResolve.forEach((resolver) => {\r\n        resolver.readKeyframes();\r\n        if (resolver.needsMeasurement) {\r\n            anyNeedsMeasurement = true;\r\n        }\r\n    });\r\n}\r\nfunction flushKeyframeResolvers() {\r\n    readAllKeyframes();\r\n    measureAllKeyframes();\r\n}\r\nclass KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\r\n        /**\r\n         * Track whether this resolver has completed. Once complete, it never\r\n         * needs to attempt keyframe resolution again.\r\n         */\r\n        this.isComplete = false;\r\n        /**\r\n         * Track whether this resolver is async. If it is, it'll be added to the\r\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\r\n         * to trigger read/write thrashing don't need to be async.\r\n         */\r\n        this.isAsync = false;\r\n        /**\r\n         * Track whether this resolver needs to perform a measurement\r\n         * to resolve its keyframes.\r\n         */\r\n        this.needsMeasurement = false;\r\n        /**\r\n         * Track whether this resolver is currently scheduled to resolve\r\n         * to allow it to be cancelled and resumed externally.\r\n         */\r\n        this.isScheduled = false;\r\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\r\n        this.onComplete = onComplete;\r\n        this.name = name;\r\n        this.motionValue = motionValue;\r\n        this.element = element;\r\n        this.isAsync = isAsync;\r\n    }\r\n    scheduleResolve() {\r\n        this.isScheduled = true;\r\n        if (this.isAsync) {\r\n            toResolve.add(this);\r\n            if (!isScheduled) {\r\n                isScheduled = true;\r\n                frame.read(readAllKeyframes);\r\n                frame.resolveKeyframes(measureAllKeyframes);\r\n            }\r\n        }\r\n        else {\r\n            this.readKeyframes();\r\n            this.complete();\r\n        }\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, name, element, motionValue } = this;\r\n        /**\r\n         * If a keyframe is null, we hydrate it either by reading it from\r\n         * the instance, or propagating from previous keyframes.\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (unresolvedKeyframes[i] === null) {\r\n                /**\r\n                 * If the first keyframe is null, we need to find its value by sampling the element\r\n                 */\r\n                if (i === 0) {\r\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\r\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n                    if (currentValue !== undefined) {\r\n                        unresolvedKeyframes[0] = currentValue;\r\n                    }\r\n                    else if (element && name) {\r\n                        const valueAsRead = element.readValue(name, finalKeyframe);\r\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\r\n                            unresolvedKeyframes[0] = valueAsRead;\r\n                        }\r\n                    }\r\n                    if (unresolvedKeyframes[0] === undefined) {\r\n                        unresolvedKeyframes[0] = finalKeyframe;\r\n                    }\r\n                    if (motionValue && currentValue === undefined) {\r\n                        motionValue.set(unresolvedKeyframes[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setFinalKeyframe() { }\r\n    measureInitialState() { }\r\n    renderEndStyles() { }\r\n    measureEndState() { }\r\n    complete() {\r\n        this.isComplete = true;\r\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\r\n        toResolve.delete(this);\r\n    }\r\n    cancel() {\r\n        if (!this.isComplete) {\r\n            this.isScheduled = false;\r\n            toResolve.delete(this);\r\n        }\r\n    }\r\n    resume() {\r\n        if (!this.isComplete)\r\n            this.scheduleResolve();\r\n    }\r\n}\r\n\r\nexport { KeyframeResolver, flushKeyframeResolvers };\r\n", "const activeAnimations = {\r\n    layout: 0,\r\n    mainThread: 0,\r\n    waapi: 0,\r\n};\r\n\r\nexport { activeAnimations };\r\n", "const instantAnimationState = {\r\n    current: false,\r\n};\r\n\r\nexport { instantAnimationState };\r\n", "import { complex } from '../../value/types/complex/index.mjs';\r\n\r\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * : 100, \"100px\", \"#fff\"\r\n * : \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nconst isAnimatable = (value, name) => {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (name === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nexport { isAnimatable };\r\n", "import { warning } from '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { isGenerator } from '../../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs';\r\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\r\n\r\nfunction hasKeyframesChanged(keyframes) {\r\n    const current = keyframes[0];\r\n    if (keyframes.length === 1)\r\n        return true;\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] !== current)\r\n            return true;\r\n    }\r\n}\r\nfunction canAnimate(keyframes, name, type, velocity) {\r\n    /**\r\n     * Check if we're able to animate between the start and end keyframes,\r\n     * and throw a warning if we're attempting to animate between one that's\r\n     * animatable and another that isn't.\r\n     */\r\n    const originKeyframe = keyframes[0];\r\n    if (originKeyframe === null)\r\n        return false;\r\n    /**\r\n     * These aren't traditionally animatable but we do support them.\r\n     * In future we could look into making this more generic or replacing\r\n     * this function with mix() === mixImmediate\r\n     */\r\n    if (name === \"display\" || name === \"visibility\")\r\n        return true;\r\n    const targetKeyframe = keyframes[keyframes.length - 1];\r\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\r\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\r\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\r\n    // Always skip if any of these are true\r\n    if (!isOriginAnimatable || !isTargetAnimatable) {\r\n        return false;\r\n    }\r\n    return (hasKeyframesChanged(keyframes) ||\r\n        ((type === \"spring\" || isGenerator(type)) && velocity));\r\n}\r\n\r\nexport { canAnimate };\r\n", "const isNotNull = (value) => value !== null;\r\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\r\n    const resolvedKeyframes = keyframes.filter(isNotNull);\r\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\r\n        ? 0\r\n        : resolvedKeyframes.length - 1;\r\n    return !index || finalKeyframe === undefined\r\n        ? resolvedKeyframes[index]\r\n        : finalKeyframe;\r\n}\r\n\r\nexport { getFinalKeyframe };\r\n", "import { time } from '../../frameloop/sync-time.mjs';\r\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { canAnimate } from './utils/can-animate.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\r\nconst MAX_RESOLVE_DELAY = 40;\r\nclass BaseAnimation {\r\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\r\n        // Track whether the animation has been stopped. Stopped animations won't restart.\r\n        this.isStopped = false;\r\n        this.hasAttemptedResolve = false;\r\n        this.createdAt = time.now();\r\n        this.options = {\r\n            autoplay,\r\n            delay,\r\n            type,\r\n            repeat,\r\n            repeatDelay,\r\n            repeatType,\r\n            ...options,\r\n        };\r\n        this.updateFinishedPromise();\r\n    }\r\n    /**\r\n     * This method uses the createdAt and resolvedAt to calculate the\r\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n     * as the following frame would then be the first frame of the animation in\r\n     * progress, which would feel snappier.\r\n     *\r\n     * However, if there's a delay (main thread work) between the creation of\r\n     * the animation and the first commited frame, we prefer to use resolvedAt\r\n     * to avoid a sudden jump into the animation.\r\n     */\r\n    calcStartTime() {\r\n        if (!this.resolvedAt)\r\n            return this.createdAt;\r\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\r\n            ? this.resolvedAt\r\n            : this.createdAt;\r\n    }\r\n    /**\r\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n     * this.resolved will synchronously flush all pending keyframe resolvers.\r\n     * This is a deoptimisation, but at its worst still batches read/writes.\r\n     */\r\n    get resolved() {\r\n        if (!this._resolved && !this.hasAttemptedResolve) {\r\n            flushKeyframeResolvers();\r\n        }\r\n        return this._resolved;\r\n    }\r\n    /**\r\n     * A method to be called when the keyframes resolver completes. This method\r\n     * will check if its possible to run the animation and, if not, skip it.\r\n     * Otherwise, it will call initPlayback on the implementing class.\r\n     */\r\n    onKeyframesResolved(keyframes, finalKeyframe) {\r\n        this.resolvedAt = time.now();\r\n        this.hasAttemptedResolve = true;\r\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\r\n        /**\r\n         * If we can't animate this value with the resolved keyframes\r\n         * then we should complete it immediately.\r\n         */\r\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\r\n            // Finish immediately\r\n            if (instantAnimationState.current || !delay) {\r\n                onUpdate &&\r\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.resolveFinishedPromise();\r\n                return;\r\n            }\r\n            // Finish after a delay\r\n            else {\r\n                this.options.duration = 0;\r\n            }\r\n        }\r\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\r\n        if (resolvedAnimation === false)\r\n            return;\r\n        this._resolved = {\r\n            keyframes,\r\n            finalKeyframe,\r\n            ...resolvedAnimation,\r\n        };\r\n        this.onPostResolved();\r\n    }\r\n    onPostResolved() { }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    flatten() {\r\n        this.options.type = \"keyframes\";\r\n        this.options.ease = \"linear\";\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nexport { BaseAnimation };\r\n", "import { time } from '../../../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\r\n\r\nconst frameloopDriver = (update) => {\r\n    const passTimestamp = ({ timestamp }) => update(timestamp);\r\n    return {\r\n        start: () => frame.update(passTimestamp, true),\r\n        stop: () => cancelFrame(passTimestamp),\r\n        /**\r\n         * If we're processing this frame we can use the\r\n         * framelocked timestamp to keep things in sync.\r\n         */\r\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\r\n    };\r\n};\r\n\r\nexport { frameloopDriver };\r\n", "import { invariant } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { calcGeneratorDuration } from '../../../../../motion-dom/dist/es/animation/generators/utils/calc-duration.mjs';\r\nimport { isGenerator } from '../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs';\r\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { activeAnimations } from '../../stats/animation-count.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    flatten() {\r\n        super.flatten();\r\n        // If we've already resolved the animation, re-initialise it\r\n        if (this._resolved) {\r\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\r\n        }\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = isGenerator(type)\r\n            ? type\r\n            : generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (process.env.NODE_ENV !== \"production\" &&\r\n            generatorFactory !== keyframes) {\r\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n        }\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        activeAnimations.mainThread++;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n        activeAnimations.mainThread--;\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n", "function attachTimeline(animation, timeline) {\r\n    animation.timeline = timeline;\r\n    animation.onfinish = null;\r\n}\r\n\r\nexport { attachTimeline };\r\n", "/*#__NO_SIDE_EFFECTS__*/\r\nfunction memo(callback) {\r\n    let result;\r\n    return () => {\r\n        if (result === undefined)\r\n            result = callback();\r\n        return result;\r\n    };\r\n}\r\n\r\nexport { memo };\r\n", "/**\r\n * Add the ability for test suites to manually set support flags\r\n * to better test more environments.\r\n */\r\nconst supportsFlags = {\r\n    linearEasing: undefined,\r\n};\r\n\r\nexport { supportsFlags };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { memo } from '../../../../../motion-utils/dist/es/memo.mjs';\r\nimport { supportsFlags } from './flags.mjs';\r\n\r\nfunction memoSupports(callback, supportsFlag) {\r\n    const memoized = memo(callback);\r\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\r\n}\r\n\r\nexport { memoSupports };\r\n", "import { memoSupports } from './memo.mjs';\r\n\r\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\r\n    try {\r\n        document\r\n            .createElement(\"div\")\r\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}, \"linearEasing\");\r\n\r\nexport { supportsLinearEasing };\r\n", "import { isBezierDefinition } from '../../../utils/is-bezier-definition.mjs';\r\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\r\nimport { generateLinearEasing } from './linear.mjs';\r\n\r\nfunction isWaapiSupportedEasing(easing) {\r\n    return Boolean((typeof easing === \"function\" && supportsLinearEasing()) ||\r\n        !easing ||\r\n        (typeof easing === \"string\" &&\r\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\r\n        isBezierDefinition(easing) ||\r\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\r\n}\r\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\r\nconst supportedWaapiEasing = {\r\n    linear: \"linear\",\r\n    ease: \"ease\",\r\n    easeIn: \"ease-in\",\r\n    easeOut: \"ease-out\",\r\n    easeInOut: \"ease-in-out\",\r\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\r\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\r\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\r\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\r\n};\r\nfunction mapEasingToNativeEasing(easing, duration) {\r\n    if (!easing) {\r\n        return undefined;\r\n    }\r\n    else if (typeof easing === \"function\" && supportsLinearEasing()) {\r\n        return generateLinearEasing(easing, duration);\r\n    }\r\n    else if (isBezierDefinition(easing)) {\r\n        return cubicBezierAsString(easing);\r\n    }\r\n    else if (Array.isArray(easing)) {\r\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\r\n            supportedWaapiEasing.easeOut);\r\n    }\r\n    else {\r\n        return supportedWaapiEasing[easing];\r\n    }\r\n}\r\n\r\nexport { cubicBezierAsString, isWaapiSupportedEasing, mapEasingToNativeEasing, supportedWaapiEasing };\r\n", "/**\r\n * Check if the value is a zero value string like \"0px\" or \"0%\"\r\n */\r\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\r\n\r\nexport { isZeroValueString };\r\n", "import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\r\n\r\nfunction isNone(value) {\r\n    if (typeof value === \"number\") {\r\n        return value === 0;\r\n    }\r\n    else if (value !== null) {\r\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport { isNone };\r\n", "import { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    ...transformPropOrder,\r\n]);\r\n\r\nexport { positionalKeys };\r\n", "import { complex } from './index.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\n\r\n/**\r\n * Properties that should default to 1 or 100%\r\n */\r\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\r\nfunction applyDefaultFilter(v) {\r\n    const [name, value] = v.slice(0, -1).split(\"(\");\r\n    if (name === \"drop-shadow\")\r\n        return v;\r\n    const [number] = value.match(floatRegex) || [];\r\n    if (!number)\r\n        return v;\r\n    const unit = value.replace(number, \"\");\r\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\r\n    if (number !== value)\r\n        defaultValue *= 100;\r\n    return name + \"(\" + defaultValue + unit + \")\";\r\n}\r\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\r\nconst filter = {\r\n    ...complex,\r\n    getAnimatableNone: (v) => {\r\n        const functions = v.match(functionRegex);\r\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\r\n    },\r\n};\r\n\r\nexport { filter };\r\n", "import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst browserNumberValueTypes = {\r\n    // Border props\r\n    borderWidth: px,\r\n    borderTopWidth: px,\r\n    borderRightWidth: px,\r\n    borderBottomWidth: px,\r\n    borderLeftWidth: px,\r\n    borderRadius: px,\r\n    radius: px,\r\n    borderTopLeftRadius: px,\r\n    borderTopRightRadius: px,\r\n    borderBottomRightRadius: px,\r\n    borderBottomLeftRadius: px,\r\n    // Positioning props\r\n    width: px,\r\n    maxWidth: px,\r\n    height: px,\r\n    maxHeight: px,\r\n    top: px,\r\n    right: px,\r\n    bottom: px,\r\n    left: px,\r\n    // Spacing props\r\n    padding: px,\r\n    paddingTop: px,\r\n    paddingRight: px,\r\n    paddingBottom: px,\r\n    paddingLeft: px,\r\n    margin: px,\r\n    marginTop: px,\r\n    marginRight: px,\r\n    marginBottom: px,\r\n    marginLeft: px,\r\n    // Misc\r\n    backgroundPositionX: px,\r\n    backgroundPositionY: px,\r\n};\r\n\r\nexport { browserNumberValueTypes };\r\n", "import { scale, alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { degrees, px, progressPercentage } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst transformValueTypes = {\r\n    rotate: degrees,\r\n    rotateX: degrees,\r\n    rotateY: degrees,\r\n    rotateZ: degrees,\r\n    scale,\r\n    scaleX: scale,\r\n    scaleY: scale,\r\n    scaleZ: scale,\r\n    skew: degrees,\r\n    skewX: degrees,\r\n    skewY: degrees,\r\n    distance: px,\r\n    translateX: px,\r\n    translateY: px,\r\n    translateZ: px,\r\n    x: px,\r\n    y: px,\r\n    z: px,\r\n    perspective: px,\r\n    transformPerspective: px,\r\n    opacity: alpha,\r\n    originX: progressPercentage,\r\n    originY: progressPercentage,\r\n    originZ: px,\r\n};\r\n\r\nexport { transformValueTypes };\r\n", "import { number } from '../../../value/types/numbers/index.mjs';\r\n\r\nconst int = {\r\n    ...number,\r\n    transform: Math.round,\r\n};\r\n\r\nexport { int };\r\n", "import { alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { browserNumberValueTypes } from './number-browser.mjs';\r\nimport { transformValueTypes } from './transform.mjs';\r\nimport { int } from './type-int.mjs';\r\n\r\nconst numberValueTypes = {\r\n    ...browserNumberValueTypes,\r\n    ...transformValueTypes,\r\n    zIndex: int,\r\n    size: px,\r\n    // SVG\r\n    fillOpacity: alpha,\r\n    strokeOpacity: alpha,\r\n    numOctaves: int,\r\n};\r\n\r\nexport { numberValueTypes };\r\n", "import { color } from '../../../value/types/color/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { numberValueTypes } from './number.mjs';\r\n\r\n/**\r\n * A map of default value types for common values\r\n */\r\nconst defaultValueTypes = {\r\n    ...numberValueTypes,\r\n    // Color props\r\n    color,\r\n    backgroundColor: color,\r\n    outlineColor: color,\r\n    fill: color,\r\n    stroke: color,\r\n    // Border props\r\n    borderColor: color,\r\n    borderTopColor: color,\r\n    borderRightColor: color,\r\n    borderBottomColor: color,\r\n    borderLeftColor: color,\r\n    filter,\r\n    WebkitFilter: filter,\r\n};\r\n/**\r\n * Gets the default ValueType for the provided value key\r\n */\r\nconst getDefaultValueType = (key) => defaultValueTypes[key];\r\n\r\nexport { defaultValueTypes, getDefaultValueType };\r\n", "import { complex } from '../../../value/types/complex/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { getDefaultValueType } from './defaults.mjs';\r\n\r\nfunction getAnimatableNone(key, value) {\r\n    let defaultValueType = getDefaultValueType(key);\r\n    if (defaultValueType !== filter)\r\n        defaultValueType = complex;\r\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n    return defaultValueType.getAnimatableNone\r\n        ? defaultValueType.getAnimatableNone(value)\r\n        : undefined;\r\n}\r\n\r\nexport { getAnimatableNone };\r\n", "import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\r\nimport { getAnimatableNone } from '../../dom/value-types/animatable-none.mjs';\r\n\r\n/**\r\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\r\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\r\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\r\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\r\n */\r\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\r\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\r\n    let i = 0;\r\n    let animatableTemplate = undefined;\r\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\r\n        const keyframe = unresolvedKeyframes[i];\r\n        if (typeof keyframe === \"string\" &&\r\n            !invalidTemplates.has(keyframe) &&\r\n            analyseComplexValue(keyframe).values.length) {\r\n            animatableTemplate = unresolvedKeyframes[i];\r\n        }\r\n        i++;\r\n    }\r\n    if (animatableTemplate && name) {\r\n        for (const noneIndex of noneKeyframeIndexes) {\r\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\r\n        }\r\n    }\r\n}\r\n\r\nexport { makeNoneKeyframesAnimatable };\r\n", "/**\r\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\r\n */\r\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\r\n\r\nexport { isNumericalString };\r\n", "import { invariant } from '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\r\nimport { isCSSVariableToken } from './is-css-variable.mjs';\r\n\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nconst splitCSSVariableRegex = \r\n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\r\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\r\nfunction parseCSSVariable(current) {\r\n    const match = splitCSSVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    const [, token1, token2, fallback] = match;\r\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\r\n}\r\nconst maxDepth = 4;\r\nfunction getVariableValue(current, element, depth = 1) {\r\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\r\n    const [token, fallback] = parseCSSVariable(current);\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        const trimmed = resolved.trim();\r\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\r\n    }\r\n    return isCSSVariableToken(fallback)\r\n        ? getVariableValue(fallback, element, depth + 1)\r\n        : fallback;\r\n}\r\n\r\nexport { getVariableValue, parseCSSVariable };\r\n", "/**\r\n * Tests a provided value against a ValueType\r\n */\r\nconst testValueType = (v) => (type) => type.test(v);\r\n\r\nexport { testValueType };\r\n", "/**\r\n * ValueType for \"auto\"\r\n */\r\nconst auto = {\r\n    test: (v) => v === \"auto\",\r\n    parse: (v) => v,\r\n};\r\n\r\nexport { auto };\r\n", "import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px, percent, degrees, vw, vh } from '../../../value/types/numbers/units.mjs';\r\nimport { testValueType } from './test.mjs';\r\nimport { auto } from './type-auto.mjs';\r\n\r\n/**\r\n * A list of value types commonly used for dimensions\r\n */\r\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\r\n/**\r\n * Tests a dimensional value against the list of dimension ValueTypes\r\n */\r\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\r\n\r\nexport { dimensionValueTypes, findDimensionValueType };\r\n", "import { isNone } from '../../animation/utils/is-none.mjs';\r\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\r\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\r\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\r\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\r\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\r\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\r\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\r\n\r\nclass DOMKeyframesResolver extends KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\r\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, element, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        super.readKeyframes();\r\n        /**\r\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            let keyframe = unresolvedKeyframes[i];\r\n            if (typeof keyframe === \"string\") {\r\n                keyframe = keyframe.trim();\r\n                if (isCSSVariableToken(keyframe)) {\r\n                    const resolved = getVariableValue(keyframe, element.current);\r\n                    if (resolved !== undefined) {\r\n                        unresolvedKeyframes[i] = resolved;\r\n                    }\r\n                    if (i === unresolvedKeyframes.length - 1) {\r\n                        this.finalKeyframe = keyframe;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\r\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\r\n         * have a far bigger performance impact.\r\n         */\r\n        this.resolveNoneKeyframes();\r\n        /**\r\n         * Check to see if unit type has changed. If so schedule jobs that will\r\n         * temporarily set styles to the destination keyframes.\r\n         * Skip if we have more than two keyframes or this isn't a positional value.\r\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\r\n         */\r\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\r\n            return;\r\n        }\r\n        const [origin, target] = unresolvedKeyframes;\r\n        const originType = findDimensionValueType(origin);\r\n        const targetType = findDimensionValueType(target);\r\n        /**\r\n         * Either we don't recognise these value types or we can animate between them.\r\n         */\r\n        if (originType === targetType)\r\n            return;\r\n        /**\r\n         * If both values are numbers or pixels, we can animate between them by\r\n         * converting them to numbers.\r\n         */\r\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\r\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n                const value = unresolvedKeyframes[i];\r\n                if (typeof value === \"string\") {\r\n                    unresolvedKeyframes[i] = parseFloat(value);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Else, the only way to resolve this is by measuring the element.\r\n             */\r\n            this.needsMeasurement = true;\r\n        }\r\n    }\r\n    resolveNoneKeyframes() {\r\n        const { unresolvedKeyframes, name } = this;\r\n        const noneKeyframeIndexes = [];\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (isNone(unresolvedKeyframes[i])) {\r\n                noneKeyframeIndexes.push(i);\r\n            }\r\n        }\r\n        if (noneKeyframeIndexes.length) {\r\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\r\n        }\r\n    }\r\n    measureInitialState() {\r\n        const { element, unresolvedKeyframes, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        if (name === \"height\") {\r\n            this.suspendedScrollY = window.pageYOffset;\r\n        }\r\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        unresolvedKeyframes[0] = this.measuredOrigin;\r\n        // Set final key frame to measure after next render\r\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n        if (measureKeyframe !== undefined) {\r\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\r\n        }\r\n    }\r\n    measureEndState() {\r\n        var _a;\r\n        const { element, name, unresolvedKeyframes } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        const value = element.getValue(name);\r\n        value && value.jump(this.measuredOrigin, false);\r\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\r\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\r\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\r\n            this.finalKeyframe = finalKeyframe;\r\n        }\r\n        // If we removed transform values, reapply them before the next render\r\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\r\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\r\n                element\r\n                    .getValue(unsetTransformName)\r\n                    .set(unsetTransformValue);\r\n            });\r\n        }\r\n        this.resolveNoneKeyframes();\r\n    }\r\n}\r\n\r\nexport { DOMKeyframesResolver };\r\n", "/**\r\n * A list of values that can be hardware-accelerated.\r\n */\r\nconst acceleratedValues = new Set([\r\n    \"opacity\",\r\n    \"clipPath\",\r\n    \"filter\",\r\n    \"transform\",\r\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\r\n    // or until we implement support for linear() easing.\r\n    // \"background-color\"\r\n]);\r\n\r\nexport { acceleratedValues };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { mapEasingToNativeEasing } from '../../../../../../motion-dom/dist/es/animation/waapi/utils/easing.mjs';\r\nimport { activeAnimations } from '../../../stats/animation-count.mjs';\r\nimport { statsBuffer } from '../../../stats/buffer.mjs';\r\n\r\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\r\n    const keyframeOptions = { [valueName]: keyframes };\r\n    if (times)\r\n        keyframeOptions.offset = times;\r\n    const easing = mapEasingToNativeEasing(ease, duration);\r\n    /**\r\n     * If this is an easing array, apply to keyframes, not animation as a whole\r\n     */\r\n    if (Array.isArray(easing))\r\n        keyframeOptions.easing = easing;\r\n    if (statsBuffer.value) {\r\n        activeAnimations.waapi++;\r\n    }\r\n    const animation = element.animate(keyframeOptions, {\r\n        delay,\r\n        duration,\r\n        easing: !Array.isArray(easing) ? easing : \"linear\",\r\n        fill: \"both\",\r\n        iterations: repeat + 1,\r\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\r\n    });\r\n    if (statsBuffer.value) {\r\n        animation.finished.finally(() => {\r\n            activeAnimations.waapi--;\r\n        });\r\n    }\r\n    return animation;\r\n}\r\n\r\nexport { startWaapiAnimation };\r\n", "import '../../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { memo } from '../../../../../../../motion-utils/dist/es/memo.mjs';\r\n\r\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\r\n\r\nexport { supportsWaapi };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { isGenerator } from '../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs';\r\nimport { attachTimeline } from '../../../../../motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs';\r\nimport { isWaapiSupportedEasing } from '../../../../../motion-dom/dist/es/animation/waapi/utils/easing.mjs';\r\nimport { supportsLinearEasing } from '../../../../../motion-dom/dist/es/utils/supports/linear-easing.mjs';\r\nimport { anticipate } from '../../easing/anticipate.mjs';\r\nimport { backInOut } from '../../easing/back.mjs';\r\nimport { circInOut } from '../../easing/circ.mjs';\r\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\r\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\r\nimport { startWaapiAnimation } from './waapi/index.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\r\n\r\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\r\nconst sampleDelta = 10; //ms\r\n/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxDuration = 20000;\r\n/**\r\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\r\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\r\n * handing off.\r\n */\r\nfunction requiresPregeneratedKeyframes(options) {\r\n    return (isGenerator(options.type) ||\r\n        options.type === \"spring\" ||\r\n        !isWaapiSupportedEasing(options.ease));\r\n}\r\nfunction pregenerateKeyframes(keyframes, options) {\r\n    /**\r\n     * Create a main-thread animation to pregenerate keyframes.\r\n     * We sample this at regular intervals to generate keyframes that we then\r\n     * linearly interpolate between.\r\n     */\r\n    const sampleAnimation = new MainThreadAnimation({\r\n        ...options,\r\n        keyframes,\r\n        repeat: 0,\r\n        delay: 0,\r\n        isGenerator: true,\r\n    });\r\n    let state = { done: false, value: keyframes[0] };\r\n    const pregeneratedKeyframes = [];\r\n    /**\r\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\r\n     * we're heading for an infinite loop.\r\n     */\r\n    let t = 0;\r\n    while (!state.done && t < maxDuration) {\r\n        state = sampleAnimation.sample(t);\r\n        pregeneratedKeyframes.push(state.value);\r\n        t += sampleDelta;\r\n    }\r\n    return {\r\n        times: undefined,\r\n        keyframes: pregeneratedKeyframes,\r\n        duration: t - sampleDelta,\r\n        ease: \"linear\",\r\n    };\r\n}\r\nconst unsupportedEasingFunctions = {\r\n    anticipate,\r\n    backInOut,\r\n    circInOut,\r\n};\r\nfunction isUnsupportedEase(key) {\r\n    return key in unsupportedEasingFunctions;\r\n}\r\nclass AcceleratedAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    initPlayback(keyframes, finalKeyframe) {\r\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\r\n        /**\r\n         * If element has since been unmounted, return false to indicate\r\n         * the animation failed to initialised.\r\n         */\r\n        if (!motionValue.owner || !motionValue.owner.current) {\r\n            return false;\r\n        }\r\n        /**\r\n         * If the user has provided an easing function name that isn't supported\r\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\r\n         * function. This will later get converted to a linear() easing function.\r\n         */\r\n        if (typeof ease === \"string\" &&\r\n            supportsLinearEasing() &&\r\n            isUnsupportedEase(ease)) {\r\n            ease = unsupportedEasingFunctions[ease];\r\n        }\r\n        /**\r\n         * If this animation needs pre-generated keyframes then generate.\r\n         */\r\n        if (requiresPregeneratedKeyframes(this.options)) {\r\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\r\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\r\n            keyframes = pregeneratedAnimation.keyframes;\r\n            // If this is a very short animation, ensure we have\r\n            // at least two keyframes to animate between as older browsers\r\n            // can't animate between a single keyframe.\r\n            if (keyframes.length === 1) {\r\n                keyframes[1] = keyframes[0];\r\n            }\r\n            duration = pregeneratedAnimation.duration;\r\n            times = pregeneratedAnimation.times;\r\n            ease = pregeneratedAnimation.ease;\r\n            type = \"keyframes\";\r\n        }\r\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\r\n        // Override the browser calculated startTime with one synchronised to other JS\r\n        // and WAAPI animations starting this event loop.\r\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        if (this.pendingTimeline) {\r\n            attachTimeline(animation, this.pendingTimeline);\r\n            this.pendingTimeline = undefined;\r\n        }\r\n        else {\r\n            /**\r\n             * Prefer the `onfinish` prop as it's more widely supported than\r\n             * the `finished` promise.\r\n             *\r\n             * Here, we synchronously set the provided MotionValue to the end\r\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\r\n             * be removed from the element which would then revert to its old styles.\r\n             */\r\n            animation.onfinish = () => {\r\n                const { onComplete } = this.options;\r\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.cancel();\r\n                this.resolveFinishedPromise();\r\n            };\r\n        }\r\n        return {\r\n            animation,\r\n            duration,\r\n            times,\r\n            type,\r\n            ease,\r\n            keyframes: keyframes,\r\n        };\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { duration } = resolved;\r\n        return millisecondsToSeconds(duration);\r\n    }\r\n    get time() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { animation } = resolved;\r\n        return millisecondsToSeconds(animation.currentTime || 0);\r\n    }\r\n    set time(newTime) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    get speed() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 1;\r\n        const { animation } = resolved;\r\n        return animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return \"idle\";\r\n        const { animation } = resolved;\r\n        return animation.playState;\r\n    }\r\n    get startTime() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return null;\r\n        const { animation } = resolved;\r\n        // Coerce to number as TypeScript incorrectly types this\r\n        // as CSSNumberish\r\n        return animation.startTime;\r\n    }\r\n    /**\r\n     * Replace the default DocumentTimeline with another AnimationTimeline.\r\n     * Currently used for scroll animations.\r\n     */\r\n    attachTimeline(timeline) {\r\n        if (!this._resolved) {\r\n            this.pendingTimeline = timeline;\r\n        }\r\n        else {\r\n            const { resolved } = this;\r\n            if (!resolved)\r\n                return noop;\r\n            const { animation } = resolved;\r\n            attachTimeline(animation, timeline);\r\n        }\r\n        return noop;\r\n    }\r\n    play() {\r\n        if (this.isStopped)\r\n            return;\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        if (animation.playState === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        animation.play();\r\n    }\r\n    pause() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.pause();\r\n    }\r\n    stop() {\r\n        this.resolver.cancel();\r\n        this.isStopped = true;\r\n        if (this.state === \"idle\")\r\n            return;\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation, keyframes, duration, type, ease, times } = resolved;\r\n        if (animation.playState === \"idle\" ||\r\n            animation.playState === \"finished\") {\r\n            return;\r\n        }\r\n        /**\r\n         * WAAPI doesn't natively have any interruption capabilities.\r\n         *\r\n         * Rather than read commited styles back out of the DOM, we can\r\n         * create a renderless JS animation and sample it twice to calculate\r\n         * its current value, \"previous\" value, and therefore allow\r\n         * Motion to calculate velocity for any subsequent animation.\r\n         */\r\n        if (this.time) {\r\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\r\n            const sampleAnimation = new MainThreadAnimation({\r\n                ...options,\r\n                keyframes,\r\n                duration,\r\n                type,\r\n                ease,\r\n                times,\r\n                isGenerator: true,\r\n            });\r\n            const sampleTime = secondsToMilliseconds(this.time);\r\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\r\n        }\r\n        const { onStop } = this.options;\r\n        onStop && onStop();\r\n        this.cancel();\r\n    }\r\n    complete() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.finish();\r\n    }\r\n    cancel() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.cancel();\r\n    }\r\n    static supports(options) {\r\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\r\n        if (!motionValue ||\r\n            !motionValue.owner ||\r\n            !(motionValue.owner.current instanceof HTMLElement)) {\r\n            return false;\r\n        }\r\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\r\n        return (supportsWaapi() &&\r\n            name &&\r\n            acceleratedValues.has(name) &&\r\n            /**\r\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\r\n             * no way to read the value from WAAPI every frame.\r\n             */\r\n            !onUpdate &&\r\n            !transformTemplate &&\r\n            !repeatDelay &&\r\n            repeatType !== \"mirror\" &&\r\n            damping !== 0 &&\r\n            type !== \"inertia\");\r\n    }\r\n}\r\n\r\nexport { AcceleratedAnimation };\r\n", "const createAxisDelta = () => ({\r\n    translate: 0,\r\n    scale: 1,\r\n    origin: 0,\r\n    originPoint: 0,\r\n});\r\nconst createDelta = () => ({\r\n    x: createAxisDelta(),\r\n    y: createAxisDelta(),\r\n});\r\nconst createAxis = () => ({ min: 0, max: 0 });\r\nconst createBox = () => ({\r\n    x: createAxis(),\r\n    y: createAxis(),\r\n});\r\n\r\nexport { createAxis, createAxisDelta, createBox, createDelta };\r\n", "const isBrowser = typeof window !== \"undefined\";\r\n\r\nexport { isBrowser };\r\n", "const featureProps = {\r\n    animation: [\r\n        \"animate\",\r\n        \"variants\",\r\n        \"whileHover\",\r\n        \"whileTap\",\r\n        \"exit\",\r\n        \"whileInView\",\r\n        \"whileFocus\",\r\n        \"whileDrag\",\r\n    ],\r\n    exit: [\"exit\"],\r\n    drag: [\"drag\", \"dragControls\"],\r\n    focus: [\"whileFocus\"],\r\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\r\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\r\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\r\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\r\n    layout: [\"layout\", \"layoutId\"],\r\n};\r\nconst featureDefinitions = {};\r\nfor (const key in featureProps) {\r\n    featureDefinitions[key] = {\r\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\r\n    };\r\n}\r\n\r\nexport { featureDefinitions };\r\n", "// Does this device prefer reduced motion? Returns `null` server-side.\r\nconst prefersReducedMotion = { current: null };\r\nconst hasReducedMotionListener = { current: false };\r\n\r\nexport { hasReducedMotionListener, prefersReducedMotion };\r\n", "import { isBrowser } from '../is-browser.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\r\n\r\nfunction initPrefersReducedMotion() {\r\n    hasReducedMotionListener.current = true;\r\n    if (!isBrowser)\r\n        return;\r\n    if (window.matchMedia) {\r\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\r\n        motionMediaQuery.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.current = false;\r\n    }\r\n}\r\n\r\nexport { initPrefersReducedMotion };\r\n", "import { color } from '../../../value/types/color/index.mjs';\r\nimport { complex } from '../../../value/types/complex/index.mjs';\r\nimport { dimensionValueTypes } from './dimensions.mjs';\r\nimport { testValueType } from './test.mjs';\r\n\r\n/**\r\n * A list of all ValueTypes\r\n */\r\nconst valueTypes = [...dimensionValueTypes, color, complex];\r\n/**\r\n * Tests a value against the list of ValueTypes\r\n */\r\nconst findValueType = (v) => valueTypes.find(testValueType(v));\r\n\r\nexport { findValueType };\r\n", "function isAnimationControls(v) {\r\n    return (v !== null &&\r\n        typeof v === \"object\" &&\r\n        typeof v.start === \"function\");\r\n}\r\n\r\nexport { isAnimationControls };\r\n", "/**\r\n * Decides if the supplied variable is variant label\r\n */\r\nfunction isVariantLabel(v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n}\r\n\r\nexport { isVariantLabel };\r\n", "const variantPriorityOrder = [\r\n    \"animate\",\r\n    \"whileInView\",\r\n    \"whileFocus\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"whileDrag\",\r\n    \"exit\",\r\n];\r\nconst variantProps = [\"initial\", ...variantPriorityOrder];\r\n\r\nexport { variantPriorityOrder, variantProps };\r\n", "import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { variantProps } from './variant-props.mjs';\r\n\r\nfunction isControllingVariants(props) {\r\n    return (isAnimationControls(props.animate) ||\r\n        variantProps.some((name) => isVariantLabel(props[name])));\r\n}\r\nfunction isVariantNode(props) {\r\n    return Boolean(isControllingVariants(props) || props.variants);\r\n}\r\n\r\nexport { isControllingVariants, isVariantNode };\r\n", "import { warnOnce } from '../../utils/warn-once.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction updateMotionValuesFromProps(element, next, prev) {\r\n    for (const key in next) {\r\n        const nextValue = next[key];\r\n        const prevValue = prev[key];\r\n        if (isMotionValue(nextValue)) {\r\n            /**\r\n             * If this is a motion value found in props or style, we want to add it\r\n             * to our visual element's motion value map.\r\n             */\r\n            element.addValue(key, nextValue);\r\n            /**\r\n             * Check the version of the incoming motion value with this version\r\n             * and warn against mismatches.\r\n             */\r\n            if (process.env.NODE_ENV === \"development\") {\r\n                warnOnce(nextValue.version === \"12.4.7\", `Attempting to mix Motion versions ${nextValue.version} with 12.4.7 may not work as expected.`);\r\n            }\r\n        }\r\n        else if (isMotionValue(prevValue)) {\r\n            /**\r\n             * If we're swapping from a motion value to a static value,\r\n             * create a new motion value from that\r\n             */\r\n            element.addValue(key, motionValue(nextValue, { owner: element }));\r\n        }\r\n        else if (prevValue !== nextValue) {\r\n            /**\r\n             * If this is a flat value that has changed, update the motion value\r\n             * or create one if it doesn't exist. We only want to do this if we're\r\n             * not handling the value with our animation state.\r\n             */\r\n            if (element.hasValue(key)) {\r\n                const existingValue = element.getValue(key);\r\n                if (existingValue.liveStyle === true) {\r\n                    existingValue.jump(nextValue);\r\n                }\r\n                else if (!existingValue.hasAnimated) {\r\n                    existingValue.set(nextValue);\r\n                }\r\n            }\r\n            else {\r\n                const latestValue = element.getStaticValue(key);\r\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\r\n            }\r\n        }\r\n    }\r\n    // Handle removed values\r\n    for (const key in prev) {\r\n        if (next[key] === undefined)\r\n            element.removeValue(key);\r\n    }\r\n    return next;\r\n}\r\n\r\nexport { updateMotionValuesFromProps };\r\n", "function getValueState(visualElement) {\r\n    const state = [{}, {}];\r\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\r\n        state[0][key] = value.get();\r\n        state[1][key] = value.getVelocity();\r\n    });\r\n    return state;\r\n}\r\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\r\n    /**\r\n     * If the variant definition is a function, resolve.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    /**\r\n     * If the variant definition is a variant label, or\r\n     * the function returned a variant label, resolve.\r\n     */\r\n    if (typeof definition === \"string\") {\r\n        definition = props.variants && props.variants[definition];\r\n    }\r\n    /**\r\n     * At this point we've resolved both functions and variant labels,\r\n     * but the resolved variant label might itself have been a function.\r\n     * If so, resolve. This can only have returned a valid target object.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    return definition;\r\n}\r\n\r\nexport { resolveVariantFromProps };\r\n", "import { time } from '../frameloop/sync-time.mjs';\r\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\r\nimport { createBox } from '../projection/geometry/models.mjs';\r\nimport { isNumericalString } from '../utils/is-numerical-string.mjs';\r\nimport { isZeroValueString } from '../utils/is-zero-value-string.mjs';\r\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\r\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\r\nimport { warnOnce } from '../utils/warn-once.mjs';\r\nimport { motionValue } from '../value/index.mjs';\r\nimport { complex } from '../value/types/complex/index.mjs';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\r\nimport { getAnimatableNone } from './dom/value-types/animatable-none.mjs';\r\nimport { findValueType } from './dom/value-types/find.mjs';\r\nimport { transformProps } from './html/utils/keys-transform.mjs';\r\nimport { visualElementStore } from './store.mjs';\r\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\r\nimport { KeyframeResolver } from './utils/KeyframesResolver.mjs';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\r\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\nconst propEventHandlers = [\r\n    \"AnimationStart\",\r\n    \"AnimationComplete\",\r\n    \"Update\",\r\n    \"BeforeLayoutMeasure\",\r\n    \"LayoutMeasure\",\r\n    \"LayoutAnimationStart\",\r\n    \"LayoutAnimationComplete\",\r\n];\r\n/**\r\n * A VisualElement is an imperative abstraction around UI elements such as\r\n * HTMLElement, SVGElement, Three.Object3D etc.\r\n */\r\nclass VisualElement {\r\n    /**\r\n     * This method takes React props and returns found MotionValues. For example, HTML\r\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\r\n     *\r\n     * This isn't an abstract method as it needs calling in the constructor, but it is\r\n     * intended to be one.\r\n     */\r\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\r\n        return {};\r\n    }\r\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\r\n        /**\r\n         * A reference to the current underlying Instance, e.g. a HTMLElement\r\n         * or Three.Mesh etc.\r\n         */\r\n        this.current = null;\r\n        /**\r\n         * A set containing references to this VisualElement's children.\r\n         */\r\n        this.children = new Set();\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        this.isVariantNode = false;\r\n        this.isControllingVariants = false;\r\n        /**\r\n         * Decides whether this VisualElement should animate in reduced motion\r\n         * mode.\r\n         *\r\n         * TODO: This is currently set on every individual VisualElement but feels\r\n         * like it could be set globally.\r\n         */\r\n        this.shouldReduceMotion = null;\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        this.values = new Map();\r\n        this.KeyframeResolver = KeyframeResolver;\r\n        /**\r\n         * Cleanup functions for active features (hover/tap/exit etc)\r\n         */\r\n        this.features = {};\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        this.valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        this.prevMotionValues = {};\r\n        /**\r\n         * An object containing a SubscriptionManager for each active event.\r\n         */\r\n        this.events = {};\r\n        /**\r\n         * An object containing an unsubscribe function for each prop event subscription.\r\n         * For example, every \"Update\" event can have multiple subscribers via\r\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\r\n         */\r\n        this.propEventSubscriptions = {};\r\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\r\n        this.render = () => {\r\n            if (!this.current)\r\n                return;\r\n            this.triggerBuild();\r\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\r\n        };\r\n        this.renderScheduledAt = 0.0;\r\n        this.scheduleRender = () => {\r\n            const now = time.now();\r\n            if (this.renderScheduledAt < now) {\r\n                this.renderScheduledAt = now;\r\n                frame.render(this.render, false, true);\r\n            }\r\n        };\r\n        const { latestValues, renderState, onUpdate } = visualState;\r\n        this.onUpdate = onUpdate;\r\n        this.latestValues = latestValues;\r\n        this.baseTarget = { ...latestValues };\r\n        this.initialValues = props.initial ? { ...latestValues } : {};\r\n        this.renderState = renderState;\r\n        this.parent = parent;\r\n        this.props = props;\r\n        this.presenceContext = presenceContext;\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        this.reducedMotionConfig = reducedMotionConfig;\r\n        this.options = options;\r\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\r\n        this.isControllingVariants = isControllingVariants(props);\r\n        this.isVariantNode = isVariantNode(props);\r\n        if (this.isVariantNode) {\r\n            this.variantChildren = new Set();\r\n        }\r\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't necessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\r\n        for (const key in initialMotionValues) {\r\n            const value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n    }\r\n    mount(instance) {\r\n        this.current = instance;\r\n        visualElementStore.set(instance, this);\r\n        if (this.projection && !this.projection.instance) {\r\n            this.projection.mount(instance);\r\n        }\r\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\r\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\r\n        }\r\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\r\n        if (!hasReducedMotionListener.current) {\r\n            initPrefersReducedMotion();\r\n        }\r\n        this.shouldReduceMotion =\r\n            this.reducedMotionConfig === \"never\"\r\n                ? false\r\n                : this.reducedMotionConfig === \"always\"\r\n                    ? true\r\n                    : prefersReducedMotion.current;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\r\n        }\r\n        if (this.parent)\r\n            this.parent.children.add(this);\r\n        this.update(this.props, this.presenceContext);\r\n    }\r\n    unmount() {\r\n        this.projection && this.projection.unmount();\r\n        cancelFrame(this.notifyUpdate);\r\n        cancelFrame(this.render);\r\n        this.valueSubscriptions.forEach((remove) => remove());\r\n        this.valueSubscriptions.clear();\r\n        this.removeFromVariantTree && this.removeFromVariantTree();\r\n        this.parent && this.parent.children.delete(this);\r\n        for (const key in this.events) {\r\n            this.events[key].clear();\r\n        }\r\n        for (const key in this.features) {\r\n            const feature = this.features[key];\r\n            if (feature) {\r\n                feature.unmount();\r\n                feature.isMounted = false;\r\n            }\r\n        }\r\n        this.current = null;\r\n    }\r\n    bindToMotionValue(key, value) {\r\n        if (this.valueSubscriptions.has(key)) {\r\n            this.valueSubscriptions.get(key)();\r\n        }\r\n        const valueIsTransform = transformProps.has(key);\r\n        if (valueIsTransform && this.onBindTransform) {\r\n            this.onBindTransform();\r\n        }\r\n        const removeOnChange = value.on(\"change\", (latestValue) => {\r\n            this.latestValues[key] = latestValue;\r\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\r\n            if (valueIsTransform && this.projection) {\r\n                this.projection.isTransformDirty = true;\r\n            }\r\n        });\r\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\r\n        let removeSyncCheck;\r\n        if (window.MotionCheckAppearSync) {\r\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\r\n        }\r\n        this.valueSubscriptions.set(key, () => {\r\n            removeOnChange();\r\n            removeOnRenderRequest();\r\n            if (removeSyncCheck)\r\n                removeSyncCheck();\r\n            if (value.owner)\r\n                value.stop();\r\n        });\r\n    }\r\n    sortNodePosition(other) {\r\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\r\n        if (!this.current ||\r\n            !this.sortInstanceNodePosition ||\r\n            this.type !== other.type) {\r\n            return 0;\r\n        }\r\n        return this.sortInstanceNodePosition(this.current, other.current);\r\n    }\r\n    updateFeatures() {\r\n        let key = \"animation\";\r\n        for (key in featureDefinitions) {\r\n            const featureDefinition = featureDefinitions[key];\r\n            if (!featureDefinition)\r\n                continue;\r\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\r\n            /**\r\n             * If this feature is enabled but not active, make a new instance.\r\n             */\r\n            if (!this.features[key] &&\r\n                FeatureConstructor &&\r\n                isEnabled(this.props)) {\r\n                this.features[key] = new FeatureConstructor(this);\r\n            }\r\n            /**\r\n             * If we have a feature, mount or update it.\r\n             */\r\n            if (this.features[key]) {\r\n                const feature = this.features[key];\r\n                if (feature.isMounted) {\r\n                    feature.update();\r\n                }\r\n                else {\r\n                    feature.mount();\r\n                    feature.isMounted = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    triggerBuild() {\r\n        this.build(this.renderState, this.latestValues, this.props);\r\n    }\r\n    /**\r\n     * Measure the current viewport box with or without transforms.\r\n     * Only measures axis-aligned boxes, rotate and skew must be manually\r\n     * removed with a re-render to work.\r\n     */\r\n    measureViewportBox() {\r\n        return this.current\r\n            ? this.measureInstanceViewportBox(this.current, this.props)\r\n            : createBox();\r\n    }\r\n    getStaticValue(key) {\r\n        return this.latestValues[key];\r\n    }\r\n    setStaticValue(key, value) {\r\n        this.latestValues[key] = value;\r\n    }\r\n    /**\r\n     * Update the provided props. Ensure any newly-added motion values are\r\n     * added to our map, old ones removed, and listeners updated.\r\n     */\r\n    update(props, presenceContext) {\r\n        if (props.transformTemplate || this.props.transformTemplate) {\r\n            this.scheduleRender();\r\n        }\r\n        this.prevProps = this.props;\r\n        this.props = props;\r\n        this.prevPresenceContext = this.presenceContext;\r\n        this.presenceContext = presenceContext;\r\n        /**\r\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\r\n         */\r\n        for (let i = 0; i < propEventHandlers.length; i++) {\r\n            const key = propEventHandlers[i];\r\n            if (this.propEventSubscriptions[key]) {\r\n                this.propEventSubscriptions[key]();\r\n                delete this.propEventSubscriptions[key];\r\n            }\r\n            const listenerName = (\"on\" + key);\r\n            const listener = props[listenerName];\r\n            if (listener) {\r\n                this.propEventSubscriptions[key] = this.on(key, listener);\r\n            }\r\n        }\r\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\r\n        if (this.handleChildMotionValue) {\r\n            this.handleChildMotionValue();\r\n        }\r\n        this.onUpdate && this.onUpdate(this);\r\n    }\r\n    getProps() {\r\n        return this.props;\r\n    }\r\n    /**\r\n     * Returns the variant definition with a given name.\r\n     */\r\n    getVariant(name) {\r\n        return this.props.variants ? this.props.variants[name] : undefined;\r\n    }\r\n    /**\r\n     * Returns the defined default transition on this component.\r\n     */\r\n    getDefaultTransition() {\r\n        return this.props.transition;\r\n    }\r\n    getTransformPagePoint() {\r\n        return this.props.transformPagePoint;\r\n    }\r\n    getClosestVariantNode() {\r\n        return this.isVariantNode\r\n            ? this\r\n            : this.parent\r\n                ? this.parent.getClosestVariantNode()\r\n                : undefined;\r\n    }\r\n    /**\r\n     * Add a child visual element to our set of children.\r\n     */\r\n    addVariantChild(child) {\r\n        const closestVariantNode = this.getClosestVariantNode();\r\n        if (closestVariantNode) {\r\n            closestVariantNode.variantChildren &&\r\n                closestVariantNode.variantChildren.add(child);\r\n            return () => closestVariantNode.variantChildren.delete(child);\r\n        }\r\n    }\r\n    /**\r\n     * Add a motion value and bind it to this visual element.\r\n     */\r\n    addValue(key, value) {\r\n        // Remove existing value if it exists\r\n        const existingValue = this.values.get(key);\r\n        if (value !== existingValue) {\r\n            if (existingValue)\r\n                this.removeValue(key);\r\n            this.bindToMotionValue(key, value);\r\n            this.values.set(key, value);\r\n            this.latestValues[key] = value.get();\r\n        }\r\n    }\r\n    /**\r\n     * Remove a motion value and unbind any active subscriptions.\r\n     */\r\n    removeValue(key) {\r\n        this.values.delete(key);\r\n        const unsubscribe = this.valueSubscriptions.get(key);\r\n        if (unsubscribe) {\r\n            unsubscribe();\r\n            this.valueSubscriptions.delete(key);\r\n        }\r\n        delete this.latestValues[key];\r\n        this.removeValueFromRenderState(key, this.renderState);\r\n    }\r\n    /**\r\n     * Check whether we have a motion value for this key\r\n     */\r\n    hasValue(key) {\r\n        return this.values.has(key);\r\n    }\r\n    getValue(key, defaultValue) {\r\n        if (this.props.values && this.props.values[key]) {\r\n            return this.props.values[key];\r\n        }\r\n        let value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\r\n            this.addValue(key, value);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * If we're trying to animate to a previously unencountered value,\r\n     * we need to check for it in our state and as a last resort read it\r\n     * directly from the instance (which might have performance implications).\r\n     */\r\n    readValue(key, target) {\r\n        var _a;\r\n        let value = this.latestValues[key] !== undefined || !this.current\r\n            ? this.latestValues[key]\r\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\r\n        if (value !== undefined && value !== null) {\r\n            if (typeof value === \"string\" &&\r\n                (isNumericalString(value) || isZeroValueString(value))) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!findValueType(value) && complex.test(target)) {\r\n                value = getAnimatableNone(key, target);\r\n            }\r\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\r\n        }\r\n        return isMotionValue(value) ? value.get() : value;\r\n    }\r\n    /**\r\n     * Set the base target to later animate back to. This is currently\r\n     * only hydrated on creation and when we first read a value.\r\n     */\r\n    setBaseTarget(key, value) {\r\n        this.baseTarget[key] = value;\r\n    }\r\n    /**\r\n     * Find the base target for a value thats been removed from all animation\r\n     * props.\r\n     */\r\n    getBaseTarget(key) {\r\n        var _a;\r\n        const { initial } = this.props;\r\n        let valueFromInitial;\r\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\r\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\r\n            if (variant) {\r\n                valueFromInitial = variant[key];\r\n            }\r\n        }\r\n        /**\r\n         * If this value still exists in the current initial variant, read that.\r\n         */\r\n        if (initial && valueFromInitial !== undefined) {\r\n            return valueFromInitial;\r\n        }\r\n        /**\r\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\r\n         * so we can read the value from an alternative source, try that.\r\n         */\r\n        const target = this.getBaseTargetFromProps(this.props, key);\r\n        if (target !== undefined && !isMotionValue(target))\r\n            return target;\r\n        /**\r\n         * If the value was initially defined on initial, but it doesn't any more,\r\n         * return undefined. Otherwise return the value as initially read from the DOM.\r\n         */\r\n        return this.initialValues[key] !== undefined &&\r\n            valueFromInitial === undefined\r\n            ? undefined\r\n            : this.baseTarget[key];\r\n    }\r\n    on(eventName, callback) {\r\n        if (!this.events[eventName]) {\r\n            this.events[eventName] = new SubscriptionManager();\r\n        }\r\n        return this.events[eventName].add(callback);\r\n    }\r\n    notify(eventName, ...args) {\r\n        if (this.events[eventName]) {\r\n            this.events[eventName].notify(...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport { VisualElement };\r\n", "/**\r\n * Provided a value and a ValueType, returns the value as that value type.\r\n */\r\nconst getValueAsType = (value, type) => {\r\n    return type && typeof value === \"number\"\r\n        ? type.transform(value)\r\n        : value;\r\n};\r\n\r\nexport { getValueAsType };\r\n", "import { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst translateAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n    transformPerspective: \"perspective\",\r\n};\r\nconst numTransforms = transformPropOrder.length;\r\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\r\nfunction buildTransform(latestValues, transform, transformTemplate) {\r\n    // The transform string we're going to build into.\r\n    let transformString = \"\";\r\n    let transformIsDefault = true;\r\n    /**\r\n     * Loop over all possible transforms in order, adding the ones that\r\n     * are present to the transform string.\r\n     */\r\n    for (let i = 0; i < numTransforms; i++) {\r\n        const key = transformPropOrder[i];\r\n        const value = latestValues[key];\r\n        if (value === undefined)\r\n            continue;\r\n        let valueIsDefault = true;\r\n        if (typeof value === \"number\") {\r\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n        else {\r\n            valueIsDefault = parseFloat(value) === 0;\r\n        }\r\n        if (!valueIsDefault || transformTemplate) {\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (!valueIsDefault) {\r\n                transformIsDefault = false;\r\n                const transformName = translateAlias[key] || key;\r\n                transformString += `${transformName}(${valueAsType}) `;\r\n            }\r\n            if (transformTemplate) {\r\n                transform[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    transformString = transformString.trim();\r\n    // If we have a custom `transform` template, pass our transform values and\r\n    // generated transformString to that before returning\r\n    if (transformTemplate) {\r\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\r\n    }\r\n    else if (transformIsDefault) {\r\n        transformString = \"none\";\r\n    }\r\n    return transformString;\r\n}\r\n\r\nexport { buildTransform };\r\n", "import { isCSSVariableName } from '../../render/dom/utils/is-css-variable.mjs';\r\n\r\nconst scaleCorrectors = {};\r\nfunction addScaleCorrector(correctors) {\r\n    for (const key in correctors) {\r\n        scaleCorrectors[key] = correctors[key];\r\n        if (isCSSVariableName(key)) {\r\n            scaleCorrectors[key].isCSSVariable = true;\r\n        }\r\n    }\r\n}\r\n\r\nexport { addScaleCorrector, scaleCorrectors };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { memo } from '../../../../../motion-utils/dist/es/memo.mjs';\r\n\r\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\r\n\r\nexport { supportsScrollTimeline };\r\n", "import { supportsScrollTimeline } from '../../utils/supports/scroll-timeline.mjs';\r\n\r\nclass BaseGroupPlaybackControls {\r\n    constructor(animations) {\r\n        // Bound to accomodate common `return animation.stop` pattern\r\n        this.stop = () => this.runAll(\"stop\");\r\n        this.animations = animations.filter(Boolean);\r\n    }\r\n    get finished() {\r\n        // Support for new finished Promise and legacy thennable API\r\n        return Promise.all(this.animations.map((animation) => \"finished\" in animation ? animation.finished : animation));\r\n    }\r\n    /**\r\n     * TODO: Filter out cancelled or stopped animations before returning\r\n     */\r\n    getAll(propName) {\r\n        return this.animations[0][propName];\r\n    }\r\n    setAll(propName, newValue) {\r\n        for (let i = 0; i < this.animations.length; i++) {\r\n            this.animations[i][propName] = newValue;\r\n        }\r\n    }\r\n    attachTimeline(timeline, fallback) {\r\n        const subscriptions = this.animations.map((animation) => {\r\n            if (supportsScrollTimeline() && animation.attachTimeline) {\r\n                return animation.attachTimeline(timeline);\r\n            }\r\n            else if (typeof fallback === \"function\") {\r\n                return fallback(animation);\r\n            }\r\n        });\r\n        return () => {\r\n            subscriptions.forEach((cancel, i) => {\r\n                cancel && cancel();\r\n                this.animations[i].stop();\r\n            });\r\n        };\r\n    }\r\n    get time() {\r\n        return this.getAll(\"time\");\r\n    }\r\n    set time(time) {\r\n        this.setAll(\"time\", time);\r\n    }\r\n    get speed() {\r\n        return this.getAll(\"speed\");\r\n    }\r\n    set speed(speed) {\r\n        this.setAll(\"speed\", speed);\r\n    }\r\n    get startTime() {\r\n        return this.getAll(\"startTime\");\r\n    }\r\n    get duration() {\r\n        let max = 0;\r\n        for (let i = 0; i < this.animations.length; i++) {\r\n            max = Math.max(max, this.animations[i].duration);\r\n        }\r\n        return max;\r\n    }\r\n    runAll(methodName) {\r\n        this.animations.forEach((controls) => controls[methodName]());\r\n    }\r\n    flatten() {\r\n        this.runAll(\"flatten\");\r\n    }\r\n    play() {\r\n        this.runAll(\"play\");\r\n    }\r\n    pause() {\r\n        this.runAll(\"pause\");\r\n    }\r\n    cancel() {\r\n        this.runAll(\"cancel\");\r\n    }\r\n    complete() {\r\n        this.runAll(\"complete\");\r\n    }\r\n}\r\n\r\nexport { BaseGroupPlaybackControls };\r\n", "import { BaseGroupPlaybackControls } from './BaseGroup.mjs';\r\n\r\n/**\r\n * TODO: This is a temporary class to support the legacy\r\n * thennable API\r\n */\r\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\r\n    then(onResolve, onReject) {\r\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\r\n    }\r\n}\r\n\r\nexport { GroupPlaybackControls };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { millisecondsToSeconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { calcGeneratorDuration, maxGeneratorDuration } from './calc-duration.mjs';\r\n\r\n/**\r\n * Create a progress => progress easing function from a generator.\r\n */\r\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\r\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\r\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\r\n    return {\r\n        type: \"keyframes\",\r\n        ease: (progress) => {\r\n            return generator.next(duration * progress).value / scale;\r\n        },\r\n        duration: millisecondsToSeconds(duration),\r\n    };\r\n}\r\n\r\nexport { createGeneratorEasing };\r\n", "import { wrap } from '../../utils/wrap.mjs';\r\nimport { isEasingArray } from './is-easing-array.mjs';\r\n\r\nfunction getEasingForSegment(easing, i) {\r\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\r\n}\r\n\r\nexport { getEasingForSegment };\r\n", "function isDOMKeyframes(keyframes) {\r\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\r\n}\r\n\r\nexport { isDOMKeyframes };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { resolveElements } from '../../../../../motion-dom/dist/es/utils/resolve-elements.mjs';\r\nimport { isDOMKeyframes } from '../utils/is-dom-keyframes.mjs';\r\n\r\nfunction resolveSubjects(subject, keyframes, scope, selectorCache) {\r\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\r\n        return resolveElements(subject, scope, selectorCache);\r\n    }\r\n    else if (subject instanceof NodeList) {\r\n        return Array.from(subject);\r\n    }\r\n    else if (Array.isArray(subject)) {\r\n        return subject;\r\n    }\r\n    else {\r\n        return [subject];\r\n    }\r\n}\r\n\r\nexport { resolveSubjects };\r\n", "function calculateRepeatDuration(duration, repeat, _repeatDelay) {\r\n    return duration * (repeat + 1);\r\n}\r\n\r\nexport { calculateRepeatDuration };\r\n", "/**\r\n * Given a absolute or relative time definition and current/prev time state of the sequence,\r\n * calculate an absolute time for the next keyframes.\r\n */\r\nfunction calcNextTime(current, next, prev, labels) {\r\n    var _a;\r\n    if (typeof next === \"number\") {\r\n        return next;\r\n    }\r\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\r\n        return Math.max(0, current + parseFloat(next));\r\n    }\r\n    else if (next === \"<\") {\r\n        return prev;\r\n    }\r\n    else {\r\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\r\n    }\r\n}\r\n\r\nexport { calcNextTime };\r\n", "import { getEasingForSegment } from '../../../easing/utils/get-easing-for-segment.mjs';\r\nimport { removeItem } from '../../../utils/array.mjs';\r\nimport { mixNumber } from '../../../utils/mix/number.mjs';\r\n\r\nfunction eraseKeyframes(sequence, startTime, endTime) {\r\n    for (let i = 0; i < sequence.length; i++) {\r\n        const keyframe = sequence[i];\r\n        if (keyframe.at > startTime && keyframe.at < endTime) {\r\n            removeItem(sequence, keyframe);\r\n            // If we remove this item we have to push the pointer back one\r\n            i--;\r\n        }\r\n    }\r\n}\r\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\r\n    /**\r\n     * Erase every existing value between currentTime and targetTime,\r\n     * this will essentially splice this timeline into any currently\r\n     * defined ones.\r\n     */\r\n    eraseKeyframes(sequence, startTime, endTime);\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        sequence.push({\r\n            value: keyframes[i],\r\n            at: mixNumber(startTime, endTime, offset[i]),\r\n            easing: getEasingForSegment(easing, i),\r\n        });\r\n    }\r\n}\r\n\r\nexport { addKeyframes, eraseKeyframes };\r\n", "/**\r\n * Take an array of times that represent repeated keyframes. For instance\r\n * if we have original times of [0, 0.5, 1] then our repeated times will\r\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\r\n * down to a 0-1 scale.\r\n */\r\nfunction normalizeTimes(times, repeat) {\r\n    for (let i = 0; i < times.length; i++) {\r\n        times[i] = times[i] / (repeat + 1);\r\n    }\r\n}\r\n\r\nexport { normalizeTimes };\r\n", "function compareByTime(a, b) {\r\n    if (a.at === b.at) {\r\n        if (a.value === null)\r\n            return 1;\r\n        if (b.value === null)\r\n            return -1;\r\n        return 0;\r\n    }\r\n    else {\r\n        return a.at - b.at;\r\n    }\r\n}\r\n\r\nexport { compareByTime };\r\n", "import { invariant } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { progress } from '../../../../../motion-utils/dist/es/progress.mjs';\r\nimport { secondsToMilliseconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { createGeneratorEasing } from '../../../../../motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs';\r\nimport { isGenerator } from '../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs';\r\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\r\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\r\nimport { calcNextTime } from './utils/calc-time.mjs';\r\nimport { addKeyframes } from './utils/edit.mjs';\r\nimport { normalizeTimes } from './utils/normalize-times.mjs';\r\nimport { compareByTime } from './utils/sort.mjs';\r\n\r\nconst defaultSegmentEasing = \"easeInOut\";\r\nconst MAX_REPEAT = 20;\r\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\r\n    const defaultDuration = defaultTransition.duration || 0.3;\r\n    const animationDefinitions = new Map();\r\n    const sequences = new Map();\r\n    const elementCache = {};\r\n    const timeLabels = new Map();\r\n    let prevTime = 0;\r\n    let currentTime = 0;\r\n    let totalDuration = 0;\r\n    /**\r\n     * Build the timeline by mapping over the sequence array and converting\r\n     * the definitions into keyframes and offsets with absolute time values.\r\n     * These will later get converted into relative offsets in a second pass.\r\n     */\r\n    for (let i = 0; i < sequence.length; i++) {\r\n        const segment = sequence[i];\r\n        /**\r\n         * If this is a timeline label, mark it and skip the rest of this iteration.\r\n         */\r\n        if (typeof segment === \"string\") {\r\n            timeLabels.set(segment, currentTime);\r\n            continue;\r\n        }\r\n        else if (!Array.isArray(segment)) {\r\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\r\n            continue;\r\n        }\r\n        let [subject, keyframes, transition = {}] = segment;\r\n        /**\r\n         * If a relative or absolute time value has been specified we need to resolve\r\n         * it in relation to the currentTime.\r\n         */\r\n        if (transition.at !== undefined) {\r\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\r\n        }\r\n        /**\r\n         * Keep track of the maximum duration in this definition. This will be\r\n         * applied to currentTime once the definition has been parsed.\r\n         */\r\n        let maxDuration = 0;\r\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\r\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\r\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\r\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\r\n            /**\r\n             * Resolve stagger() if defined.\r\n             */\r\n            const calculatedDelay = typeof delay === \"function\"\r\n                ? delay(elementIndex, numSubjects)\r\n                : delay;\r\n            /**\r\n             * If this animation should and can use a spring, generate a spring easing function.\r\n             */\r\n            const numKeyframes = valueKeyframesAsList.length;\r\n            const createGenerator = isGenerator(type)\r\n                ? type\r\n                : generators === null || generators === void 0 ? void 0 : generators[type];\r\n            if (numKeyframes <= 2 && createGenerator) {\r\n                /**\r\n                 * As we're creating an easing function from a spring,\r\n                 * ideally we want to generate it using the real distance\r\n                 * between the two keyframes. However this isn't always\r\n                 * possible - in these situations we use 0-100.\r\n                 */\r\n                let absoluteDelta = 100;\r\n                if (numKeyframes === 2 &&\r\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\r\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\r\n                    absoluteDelta = Math.abs(delta);\r\n                }\r\n                const springTransition = { ...remainingTransition };\r\n                if (duration !== undefined) {\r\n                    springTransition.duration = secondsToMilliseconds(duration);\r\n                }\r\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\r\n                ease = springEasing.ease;\r\n                duration = springEasing.duration;\r\n            }\r\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\r\n            const startTime = currentTime + calculatedDelay;\r\n            /**\r\n             * If there's only one time offset of 0, fill in a second with length 1\r\n             */\r\n            if (times.length === 1 && times[0] === 0) {\r\n                times[1] = 1;\r\n            }\r\n            /**\r\n             * Fill out if offset if fewer offsets than keyframes\r\n             */\r\n            const remainder = times.length - valueKeyframesAsList.length;\r\n            remainder > 0 && fillOffset(times, remainder);\r\n            /**\r\n             * If only one value has been set, ie [1], push a null to the start of\r\n             * the keyframe array. This will let us mark a keyframe at this point\r\n             * that will later be hydrated with the previous value.\r\n             */\r\n            valueKeyframesAsList.length === 1 &&\r\n                valueKeyframesAsList.unshift(null);\r\n            /**\r\n             * Handle repeat options\r\n             */\r\n            if (repeat) {\r\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\r\n                duration = calculateRepeatDuration(duration, repeat);\r\n                const originalKeyframes = [...valueKeyframesAsList];\r\n                const originalTimes = [...times];\r\n                ease = Array.isArray(ease) ? [...ease] : [ease];\r\n                const originalEase = [...ease];\r\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\r\n                    valueKeyframesAsList.push(...originalKeyframes);\r\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\r\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\r\n                        ease.push(keyframeIndex === 0\r\n                            ? \"linear\"\r\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\r\n                    }\r\n                }\r\n                normalizeTimes(times, repeat);\r\n            }\r\n            const targetTime = startTime + duration;\r\n            /**\r\n             * Add keyframes, mapping offsets to absolute time.\r\n             */\r\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\r\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\r\n            totalDuration = Math.max(targetTime, totalDuration);\r\n        };\r\n        if (isMotionValue(subject)) {\r\n            const subjectSequence = getSubjectSequence(subject, sequences);\r\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\r\n        }\r\n        else {\r\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\r\n            const numSubjects = subjects.length;\r\n            /**\r\n             * For every element in this segment, process the defined values.\r\n             */\r\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\r\n                /**\r\n                 * Cast necessary, but we know these are of this type\r\n                 */\r\n                keyframes = keyframes;\r\n                transition = transition;\r\n                const thisSubject = subjects[subjectIndex];\r\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\r\n                for (const key in keyframes) {\r\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\r\n                }\r\n            }\r\n        }\r\n        prevTime = currentTime;\r\n        currentTime += maxDuration;\r\n    }\r\n    /**\r\n     * For every element and value combination create a new animation.\r\n     */\r\n    sequences.forEach((valueSequences, element) => {\r\n        for (const key in valueSequences) {\r\n            const valueSequence = valueSequences[key];\r\n            /**\r\n             * Arrange all the keyframes in ascending time order.\r\n             */\r\n            valueSequence.sort(compareByTime);\r\n            const keyframes = [];\r\n            const valueOffset = [];\r\n            const valueEasing = [];\r\n            /**\r\n             * For each keyframe, translate absolute times into\r\n             * relative offsets based on the total duration of the timeline.\r\n             */\r\n            for (let i = 0; i < valueSequence.length; i++) {\r\n                const { at, value, easing } = valueSequence[i];\r\n                keyframes.push(value);\r\n                valueOffset.push(progress(0, totalDuration, at));\r\n                valueEasing.push(easing || \"easeOut\");\r\n            }\r\n            /**\r\n             * If the first keyframe doesn't land on offset: 0\r\n             * provide one by duplicating the initial keyframe. This ensures\r\n             * it snaps to the first keyframe when the animation starts.\r\n             */\r\n            if (valueOffset[0] !== 0) {\r\n                valueOffset.unshift(0);\r\n                keyframes.unshift(keyframes[0]);\r\n                valueEasing.unshift(defaultSegmentEasing);\r\n            }\r\n            /**\r\n             * If the last keyframe doesn't land on offset: 1\r\n             * provide one with a null wildcard value. This will ensure it\r\n             * stays static until the end of the animation.\r\n             */\r\n            if (valueOffset[valueOffset.length - 1] !== 1) {\r\n                valueOffset.push(1);\r\n                keyframes.push(null);\r\n            }\r\n            if (!animationDefinitions.has(element)) {\r\n                animationDefinitions.set(element, {\r\n                    keyframes: {},\r\n                    transition: {},\r\n                });\r\n            }\r\n            const definition = animationDefinitions.get(element);\r\n            definition.keyframes[key] = keyframes;\r\n            definition.transition[key] = {\r\n                ...defaultTransition,\r\n                duration: totalDuration,\r\n                ease: valueEasing,\r\n                times: valueOffset,\r\n                ...sequenceTransition,\r\n            };\r\n        }\r\n    });\r\n    return animationDefinitions;\r\n}\r\nfunction getSubjectSequence(subject, sequences) {\r\n    !sequences.has(subject) && sequences.set(subject, {});\r\n    return sequences.get(subject);\r\n}\r\nfunction getValueSequence(name, sequences) {\r\n    if (!sequences[name])\r\n        sequences[name] = [];\r\n    return sequences[name];\r\n}\r\nfunction keyframesAsList(keyframes) {\r\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\r\n}\r\nfunction getValueTransition(transition, key) {\r\n    return transition && transition[key]\r\n        ? {\r\n            ...transition,\r\n            ...transition[key],\r\n        }\r\n        : { ...transition };\r\n}\r\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\r\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\r\n\r\nexport { createAnimationsFromSequence, getValueTransition };\r\n", "function getValueTransition(transition, key) {\r\n    return transition\r\n        ? transition[key] ||\r\n            transition[\"default\"] ||\r\n            transition\r\n        : undefined;\r\n}\r\n\r\nexport { getValueTransition };\r\n", "const isKeyframesTarget = (v) => {\r\n    return Array.isArray(v);\r\n};\r\n\r\nexport { isKeyframesTarget };\r\n", "import { isKeyframesTarget } from '../animation/utils/is-keyframes-target.mjs';\r\n\r\nconst isCustomValue = (v) => {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nconst resolveFinalValueInKeyframes = (v) => {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\r\n\r\nexport { isCustomValue, resolveFinalValueInKeyframes };\r\n", "import { resolveVariantFromProps } from './resolve-variants.mjs';\r\n\r\nfunction resolveVariant(visualElement, definition, custom) {\r\n    const props = visualElement.getProps();\r\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\r\n}\r\n\r\nexport { resolveVariant };\r\n", "import { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\n\r\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\r\nfunction setMotionValue(visualElement, key, value) {\r\n    if (visualElement.hasValue(key)) {\r\n        visualElement.getValue(key).set(value);\r\n    }\r\n    else {\r\n        visualElement.addValue(key, motionValue(value));\r\n    }\r\n}\r\nfunction setTarget(visualElement, definition) {\r\n    const resolved = resolveVariant(visualElement, definition);\r\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\r\n    target = { ...target, ...transitionEnd };\r\n    for (const key in target) {\r\n        const value = resolveFinalValueInKeyframes(target[key]);\r\n        setMotionValue(visualElement, key, value);\r\n    }\r\n}\r\n\r\nexport { setTarget };\r\n", "import { isMotionValue } from '../utils/is-motion-value.mjs';\r\n\r\nfunction isWillChangeMotionValue(value) {\r\n    return Boolean(isMotionValue(value) && value.add);\r\n}\r\n\r\nexport { isWillChangeMotionValue };\r\n", "import { isWillChangeMotionValue } from './is.mjs';\r\n\r\nfunction addValueToWillChange(visualElement, key) {\r\n    const willChange = visualElement.getValue(\"willChange\");\r\n    /**\r\n     * It could be that a user has set willChange to a regular MotionValue,\r\n     * in which case we can't add the value to it.\r\n     */\r\n    if (isWillChangeMotionValue(willChange)) {\r\n        return willChange.add(key);\r\n    }\r\n}\r\n\r\nexport { addValueToWillChange };\r\n", "import { optimizedAppearDataAttribute } from './data-id.mjs';\r\n\r\nfunction getOptimisedAppearId(visualElement) {\r\n    return visualElement.props[optimizedAppearDataAttribute];\r\n}\r\n\r\nexport { getOptimisedAppearId };\r\n", "import { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nconst underDampedSpring = {\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restSpeed: 10,\r\n};\r\nconst criticallyDampedSpring = (target) => ({\r\n    type: \"spring\",\r\n    stiffness: 550,\r\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\r\n    restSpeed: 10,\r\n});\r\nconst keyframesTransition = {\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n};\r\n/**\r\n * Default easing curve is a slightly shallower version of\r\n * the default browser easing curve.\r\n */\r\nconst ease = {\r\n    type: \"keyframes\",\r\n    ease: [0.25, 0.1, 0.35, 1],\r\n    duration: 0.3,\r\n};\r\nconst getDefaultTransition = (valueKey, { keyframes }) => {\r\n    if (keyframes.length > 2) {\r\n        return keyframesTransition;\r\n    }\r\n    else if (transformProps.has(valueKey)) {\r\n        return valueKey.startsWith(\"scale\")\r\n            ? criticallyDampedSpring(keyframes[1])\r\n            : underDampedSpring;\r\n    }\r\n    return ease;\r\n};\r\n\r\nexport { getDefaultTransition };\r\n", "/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\r\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\r\n    return !!Object.keys(transition).length;\r\n}\r\n\r\nexport { isTransitionDefined };\r\n", "import { GroupPlaybackControls } from '../../../../../motion-dom/dist/es/animation/controls/Group.mjs';\r\nimport { getValueTransition } from '../../../../../motion-dom/dist/es/animation/utils/get-value-transition.mjs';\r\nimport '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { secondsToMilliseconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\r\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\r\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\r\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\r\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\r\n\r\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\r\n    const valueTransition = getValueTransition(transition, name) || {};\r\n    /**\r\n     * Most transition values are currently completely overwritten by value-specific\r\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n     * delay actually does inherit from the root transition if not value-specific.\r\n     */\r\n    const delay = valueTransition.delay || transition.delay || 0;\r\n    /**\r\n     * Elapsed isn't a public transition option but can be passed through from\r\n     * optimized appear effects in milliseconds.\r\n     */\r\n    let { elapsed = 0 } = transition;\r\n    elapsed = elapsed - secondsToMilliseconds(delay);\r\n    let options = {\r\n        keyframes: Array.isArray(target) ? target : [null, target],\r\n        ease: \"easeOut\",\r\n        velocity: value.getVelocity(),\r\n        ...valueTransition,\r\n        delay: -elapsed,\r\n        onUpdate: (v) => {\r\n            value.set(v);\r\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n        },\r\n        onComplete: () => {\r\n            onComplete();\r\n            valueTransition.onComplete && valueTransition.onComplete();\r\n        },\r\n        name,\r\n        motionValue: value,\r\n        element: isHandoff ? undefined : element,\r\n    };\r\n    /**\r\n     * If there's no transition defined for this value, we can generate\r\n     * unqiue transition settings for this value.\r\n     */\r\n    if (!isTransitionDefined(valueTransition)) {\r\n        options = {\r\n            ...options,\r\n            ...getDefaultTransition(name, options),\r\n        };\r\n    }\r\n    /**\r\n     * Both WAAPI and our internal animation functions use durations\r\n     * as defined by milliseconds, while our external API defines them\r\n     * as seconds.\r\n     */\r\n    if (options.duration) {\r\n        options.duration = secondsToMilliseconds(options.duration);\r\n    }\r\n    if (options.repeatDelay) {\r\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\r\n    }\r\n    if (options.from !== undefined) {\r\n        options.keyframes[0] = options.from;\r\n    }\r\n    let shouldSkip = false;\r\n    if (options.type === false ||\r\n        (options.duration === 0 && !options.repeatDelay)) {\r\n        options.duration = 0;\r\n        if (options.delay === 0) {\r\n            shouldSkip = true;\r\n        }\r\n    }\r\n    if (instantAnimationState.current ||\r\n        MotionGlobalConfig.skipAnimations) {\r\n        shouldSkip = true;\r\n        options.duration = 0;\r\n        options.delay = 0;\r\n    }\r\n    /**\r\n     * If we can or must skip creating the animation, and apply only\r\n     * the final keyframe, do so. We also check once keyframes are resolved but\r\n     * this early check prevents the need to create an animation at all.\r\n     */\r\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\r\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\r\n        if (finalKeyframe !== undefined) {\r\n            frame.update(() => {\r\n                options.onUpdate(finalKeyframe);\r\n                options.onComplete();\r\n            });\r\n            // We still want to return some animation controls here rather\r\n            // than returning undefined\r\n            return new GroupPlaybackControls([]);\r\n        }\r\n    }\r\n    /**\r\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\r\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\r\n     * optimised animation.\r\n     */\r\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\r\n        return new AcceleratedAnimation(options);\r\n    }\r\n    else {\r\n        return new MainThreadAnimation(options);\r\n    }\r\n};\r\n\r\nexport { animateMotionValue };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { getValueTransition } from '../../../../../motion-dom/dist/es/animation/utils/get-value-transition.mjs';\r\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\r\nimport { setTarget } from '../../render/utils/setters.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\r\nimport { animateMotionValue } from './motion-value.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type &&\r\n        visualElement.animationState &&\r\n        visualElement.animationState.getState()[type];\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\r\n        const valueTarget = target[key];\r\n        if (valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        const valueTransition = {\r\n            delay,\r\n            ...getValueTransition(transition || {}, key),\r\n        };\r\n        /**\r\n         * If this is the first time a value is being animated, check\r\n         * to see if we're handling off from an existing animation.\r\n         */\r\n        let isHandoff = false;\r\n        if (window.MotionHandoffAnimation) {\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (appearId) {\r\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\r\n                if (startTime !== null) {\r\n                    valueTransition.startTime = startTime;\r\n                    isHandoff = true;\r\n                }\r\n            }\r\n        }\r\n        addValueToWillChange(visualElement, key);\r\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\r\n            ? { type: false }\r\n            : valueTransition, visualElement, isHandoff));\r\n        const animation = value.animation;\r\n        if (animation) {\r\n            animations.push(animation);\r\n        }\r\n    }\r\n    if (transitionEnd) {\r\n        Promise.all(animations).then(() => {\r\n            frame.update(() => {\r\n                transitionEnd && setTarget(visualElement, transitionEnd);\r\n            });\r\n        });\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateTarget };\r\n", "function isSVGElement(element) {\r\n    return element instanceof SVGElement && element.tagName !== \"svg\";\r\n}\r\n\r\nexport { isSVGElement };\r\n", "import { VisualElement } from '../VisualElement.mjs';\r\nimport { DOMKeyframesResolver } from './DOMKeyframesResolver.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nclass DOMVisualElement extends VisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.KeyframeResolver = DOMKeyframesResolver;\r\n    }\r\n    sortInstanceNodePosition(a, b) {\r\n        /**\r\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n         * to true if b preceeds a.\r\n         */\r\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props.style\r\n            ? props.style[key]\r\n            : undefined;\r\n    }\r\n    removeValueFromRenderState(key, { vars, style }) {\r\n        delete vars[key];\r\n        delete style[key];\r\n    }\r\n    handleChildMotionValue() {\r\n        if (this.childSubscription) {\r\n            this.childSubscription();\r\n            delete this.childSubscription;\r\n        }\r\n        const { children } = this.props;\r\n        if (isMotionValue(children)) {\r\n            this.childSubscription = children.on(\"change\", (latest) => {\r\n                if (this.current) {\r\n                    this.current.textContent = `${latest}`;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport { DOMVisualElement };\r\n", "import { isCSSVariableName } from '../../dom/utils/is-css-variable.mjs';\r\nimport { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { buildTransform } from './build-transform.mjs';\r\nimport { transformProps } from './keys-transform.mjs';\r\n\r\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\r\n    const { style, vars, transformOrigin } = state;\r\n    // Track whether we encounter any transform or transformOrigin values.\r\n    let hasTransform = false;\r\n    let hasTransformOrigin = false;\r\n    /**\r\n     * Loop over all our latest animated values and decide whether to handle them\r\n     * as a style or CSS variable.\r\n     *\r\n     * Transforms and transform origins are kept separately for further processing.\r\n     */\r\n    for (const key in latestValues) {\r\n        const value = latestValues[key];\r\n        if (transformProps.has(key)) {\r\n            // If this is a transform, flag to enable further transform processing\r\n            hasTransform = true;\r\n            continue;\r\n        }\r\n        else if (isCSSVariableName(key)) {\r\n            vars[key] = value;\r\n            continue;\r\n        }\r\n        else {\r\n            // Convert the value to its default value type, ie 0 -> \"0px\"\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (key.startsWith(\"origin\")) {\r\n                // If this is a transform origin, flag and enable further transform-origin processing\r\n                hasTransformOrigin = true;\r\n                transformOrigin[key] =\r\n                    valueAsType;\r\n            }\r\n            else {\r\n                style[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    if (!latestValues.transform) {\r\n        if (hasTransform || transformTemplate) {\r\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\r\n        }\r\n        else if (style.transform) {\r\n            /**\r\n             * If we have previously created a transform but currently don't have any,\r\n             * reset transform style to none.\r\n             */\r\n            style.transform = \"none\";\r\n        }\r\n    }\r\n    /**\r\n     * Build a transformOrigin style. Uses the same defaults as the browser for\r\n     * undefined origins.\r\n     */\r\n    if (hasTransformOrigin) {\r\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\r\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\r\n    }\r\n}\r\n\r\nexport { buildHTMLStyles };\r\n", "import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst dashKeys = {\r\n    offset: \"stroke-dashoffset\",\r\n    array: \"stroke-dasharray\",\r\n};\r\nconst camelKeys = {\r\n    offset: \"strokeDashoffset\",\r\n    array: \"strokeDasharray\",\r\n};\r\n/**\r\n * Build SVG path properties. Uses the path's measured length to convert\r\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\r\n * and stroke-dasharray attributes.\r\n *\r\n * This function is mutative to reduce per-frame GC.\r\n */\r\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\r\n    // Normalise path length by setting SVG attribute pathLength to 1\r\n    attrs.pathLength = 1;\r\n    // We use dash case when setting attributes directly to the DOM node and camel case\r\n    // when defining props on a React component.\r\n    const keys = useDashCase ? dashKeys : camelKeys;\r\n    // Build the dash offset\r\n    attrs[keys.offset] = px.transform(-offset);\r\n    // Build the dash array\r\n    const pathLength = px.transform(length);\r\n    const pathSpacing = px.transform(spacing);\r\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\r\n}\r\n\r\nexport { buildSVGPath };\r\n", "import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nfunction calcOrigin(origin, offset, size) {\r\n    return typeof origin === \"string\"\r\n        ? origin\r\n        : px.transform(offset + size * origin);\r\n}\r\n/**\r\n * The SVG transform origin defaults are different to CSS and is less intuitive,\r\n * so we use the measured dimensions of the SVG to reconcile these.\r\n */\r\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\r\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\r\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\r\n    return `${pxOriginX} ${pxOriginY}`;\r\n}\r\n\r\nexport { calcSVGTransformOrigin };\r\n", "import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\r\nimport { buildSVGPath } from './path.mjs';\r\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\r\n\r\n/**\r\n * Build SVG visual attrbutes, like cx and style.transform\r\n */\r\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \r\n// This is object creation, which we try to avoid per-frame.\r\n...latest }, isSVGTag, transformTemplate) {\r\n    buildHTMLStyles(state, latest, transformTemplate);\r\n    /**\r\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\r\n     * as normal HTML tags.\r\n     */\r\n    if (isSVGTag) {\r\n        if (state.style.viewBox) {\r\n            state.attrs.viewBox = state.style.viewBox;\r\n        }\r\n        return;\r\n    }\r\n    state.attrs = state.style;\r\n    state.style = {};\r\n    const { attrs, style, dimensions } = state;\r\n    /**\r\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\r\n     * and copy it into style.\r\n     */\r\n    if (attrs.transform) {\r\n        if (dimensions)\r\n            style.transform = attrs.transform;\r\n        delete attrs.transform;\r\n    }\r\n    // Parse transformOrigin\r\n    if (dimensions &&\r\n        (originX !== undefined || originY !== undefined || style.transform)) {\r\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\r\n    }\r\n    // Render attrX/attrY/attrScale as attributes\r\n    if (attrX !== undefined)\r\n        attrs.x = attrX;\r\n    if (attrY !== undefined)\r\n        attrs.y = attrY;\r\n    if (attrScale !== undefined)\r\n        attrs.scale = attrScale;\r\n    // Build SVG path if one has been defined\r\n    if (pathLength !== undefined) {\r\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\r\n    }\r\n}\r\n\r\nexport { buildSVGAttrs };\r\n", "/**\r\n * A set of attribute names that are always read/written as camel case.\r\n */\r\nconst camelCaseAttributes = new Set([\r\n    \"baseFrequency\",\r\n    \"diffuseConstant\",\r\n    \"kernelMatrix\",\r\n    \"kernelUnitLength\",\r\n    \"keySplines\",\r\n    \"keyTimes\",\r\n    \"limitingConeAngle\",\r\n    \"markerHeight\",\r\n    \"markerWidth\",\r\n    \"numOctaves\",\r\n    \"targetX\",\r\n    \"targetY\",\r\n    \"surfaceScale\",\r\n    \"specularConstant\",\r\n    \"specularExponent\",\r\n    \"stdDeviation\",\r\n    \"tableValues\",\r\n    \"viewBox\",\r\n    \"gradientTransform\",\r\n    \"pathLength\",\r\n    \"startOffset\",\r\n    \"textLength\",\r\n    \"lengthAdjust\",\r\n]);\r\n\r\nexport { camelCaseAttributes };\r\n", "const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\r\n\r\nexport { isSVGTag };\r\n", "function updateSVGDimensions(instance, renderState) {\r\n    try {\r\n        renderState.dimensions =\r\n            typeof instance.getBBox === \"function\"\r\n                ? instance.getBBox()\r\n                : instance.getBoundingClientRect();\r\n    }\r\n    catch (e) {\r\n        // Most likely trying to measure an unrendered element under Firefox\r\n        renderState.dimensions = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n}\r\n\r\nexport { updateSVGDimensions };\r\n", "function renderHTML(element, { style, vars }, styleProp, projection) {\r\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\r\n    // Loop over any CSS variables and assign those.\r\n    for (const key in vars) {\r\n        element.style.setProperty(key, vars[key]);\r\n    }\r\n}\r\n\r\nexport { renderHTML };\r\n", "import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\r\nimport { renderHTML } from '../../html/utils/render.mjs';\r\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\r\n\r\nfunction renderSVG(element, renderState, _styleProp, projection) {\r\n    renderHTML(element, renderState, undefined, projection);\r\n    for (const key in renderState.attrs) {\r\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\r\n    }\r\n}\r\n\r\nexport { renderSVG };\r\n", "import { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\r\nimport { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nfunction isForcedMotionValue(key, { layout, layoutId }) {\r\n    return (transformProps.has(key) ||\r\n        key.startsWith(\"origin\") ||\r\n        ((layout || layoutId !== undefined) &&\r\n            (!!scaleCorrectors[key] || key === \"opacity\")));\r\n}\r\n\r\nexport { isForcedMotionValue };\r\n", "import { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\r\nimport { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    var _a;\r\n    const { style } = props;\r\n    const newValues = {};\r\n    for (const key in style) {\r\n        if (isMotionValue(style[key]) ||\r\n            (prevProps.style &&\r\n                isMotionValue(prevProps.style[key])) ||\r\n            isForcedMotionValue(key, props) ||\r\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\r\n            newValues[key] = style[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n", "import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\r\n    for (const key in props) {\r\n        if (isMotionValue(props[key]) ||\r\n            isMotionValue(prevProps[key])) {\r\n            const targetKey = transformPropOrder.indexOf(key) !== -1\r\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\r\n                : key;\r\n            newValues[targetKey] = props[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n", "import { frame } from '../../frameloop/frame.mjs';\r\nimport { createBox } from '../../projection/geometry/models.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { transformProps } from '../html/utils/keys-transform.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\nimport { updateSVGDimensions } from './utils/measure.mjs';\r\nimport { renderSVG } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nclass SVGVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"svg\";\r\n        this.isSVGTag = false;\r\n        this.measureInstanceViewportBox = createBox;\r\n        this.updateDimensions = () => {\r\n            if (this.current && !this.renderState.dimensions) {\r\n                updateSVGDimensions(this.current, this.renderState);\r\n            }\r\n        };\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props[key];\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\r\n        return instance.getAttribute(key);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n    onBindTransform() {\r\n        if (this.current && !this.renderState.dimensions) {\r\n            frame.postRender(this.updateDimensions);\r\n        }\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\r\n    }\r\n    renderInstance(instance, renderState, styleProp, projection) {\r\n        renderSVG(instance, renderState, styleProp, projection);\r\n    }\r\n    mount(instance) {\r\n        this.isSVGTag = isSVGTag(instance.tagName);\r\n        super.mount(instance);\r\n    }\r\n}\r\n\r\nexport { SVGVisualElement };\r\n", "/**\r\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\r\n * it's easier to consider each axis individually. This function returns a bounding box\r\n * as a map of single-axis min/max values.\r\n */\r\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\r\n    return {\r\n        x: { min: left, max: right },\r\n        y: { min: top, max: bottom },\r\n    };\r\n}\r\nfunction convertBoxToBoundingBox({ x, y }) {\r\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\r\n}\r\n/**\r\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\r\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\r\n * when measuring DOM elements and DOM event points.\r\n */\r\nfunction transformBoxPoints(point, transformPoint) {\r\n    if (!transformPoint)\r\n        return point;\r\n    const topLeft = transformPoint({ x: point.left, y: point.top });\r\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\r\n    return {\r\n        top: topLeft.y,\r\n        left: topLeft.x,\r\n        bottom: bottomRight.y,\r\n        right: bottomRight.x,\r\n    };\r\n}\r\n\r\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\r\n", "function isIdentityScale(scale) {\r\n    return scale === undefined || scale === 1;\r\n}\r\nfunction hasScale({ scale, scaleX, scaleY }) {\r\n    return (!isIdentityScale(scale) ||\r\n        !isIdentityScale(scaleX) ||\r\n        !isIdentityScale(scaleY));\r\n}\r\nfunction hasTransform(values) {\r\n    return (hasScale(values) ||\r\n        has2DTranslate(values) ||\r\n        values.z ||\r\n        values.rotate ||\r\n        values.rotateX ||\r\n        values.rotateY ||\r\n        values.skewX ||\r\n        values.skewY);\r\n}\r\nfunction has2DTranslate(values) {\r\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\r\n}\r\nfunction is2DTranslate(value) {\r\n    return value && value !== \"0%\";\r\n}\r\n\r\nexport { has2DTranslate, hasScale, hasTransform };\r\n", "import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\r\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const { visualElement } = node.options;\r\n        if (visualElement &&\r\n            visualElement.props.style &&\r\n            visualElement.props.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.x = 1.0;\r\n    }\r\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.y = 1.0;\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\r\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\r\n}\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\r\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n", "import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\r\nimport { translateAxis } from '../geometry/delta-apply.mjs';\r\n\r\nfunction measureViewportBox(instance, transformPoint) {\r\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\r\n}\r\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\r\n    const viewportBox = measureViewportBox(element, transformPagePoint);\r\n    const { scroll } = rootProjectionNode;\r\n    if (scroll) {\r\n        translateAxis(viewportBox.x, scroll.offset.x);\r\n        translateAxis(viewportBox.y, scroll.offset.y);\r\n    }\r\n    return viewportBox;\r\n}\r\n\r\nexport { measurePageBox, measureViewportBox };\r\n", "import { measureViewportBox } from '../../projection/utils/measure.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { isCSSVariableName } from '../dom/utils/is-css-variable.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { transformProps } from './utils/keys-transform.mjs';\r\nimport { renderHTML } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nfunction getComputedStyle(element) {\r\n    return window.getComputedStyle(element);\r\n}\r\nclass HTMLVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"html\";\r\n        this.renderInstance = renderHTML;\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        else {\r\n            const computedStyle = getComputedStyle(instance);\r\n            const value = (isCSSVariableName(key)\r\n                ? computedStyle.getPropertyValue(key)\r\n                : computedStyle[key]) || 0;\r\n            return typeof value === \"string\" ? value.trim() : value;\r\n        }\r\n    }\r\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\r\n        return measureViewportBox(instance, transformPagePoint);\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n}\r\n\r\nexport { HTMLVisualElement, getComputedStyle };\r\n", "import { createBox } from '../../projection/geometry/models.mjs';\r\nimport { VisualElement } from '../VisualElement.mjs';\r\n\r\nfunction isObjectKey(key, object) {\r\n    return key in object;\r\n}\r\nclass ObjectVisualElement extends VisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"object\";\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (isObjectKey(key, instance)) {\r\n            const value = instance[key];\r\n            if (typeof value === \"string\" || typeof value === \"number\") {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    getBaseTargetFromProps() {\r\n        return undefined;\r\n    }\r\n    removeValueFromRenderState(key, renderState) {\r\n        delete renderState.output[key];\r\n    }\r\n    measureInstanceViewportBox() {\r\n        return createBox();\r\n    }\r\n    build(renderState, latestValues) {\r\n        Object.assign(renderState.output, latestValues);\r\n    }\r\n    renderInstance(instance, { output }) {\r\n        Object.assign(instance, output);\r\n    }\r\n    sortInstanceNodePosition() {\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport { ObjectVisualElement };\r\n", "import { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\r\nimport { SVGVisualElement } from '../../render/svg/SVGVisualElement.mjs';\r\nimport { HTMLVisualElement } from '../../render/html/HTMLVisualElement.mjs';\r\nimport { visualElementStore } from '../../render/store.mjs';\r\nimport { ObjectVisualElement } from '../../render/object/ObjectVisualElement.mjs';\r\n\r\nfunction createDOMVisualElement(element) {\r\n    const options = {\r\n        presenceContext: null,\r\n        props: {},\r\n        visualState: {\r\n            renderState: {\r\n                transform: {},\r\n                transformOrigin: {},\r\n                style: {},\r\n                vars: {},\r\n                attrs: {},\r\n            },\r\n            latestValues: {},\r\n        },\r\n    };\r\n    const node = isSVGElement(element)\r\n        ? new SVGVisualElement(options)\r\n        : new HTMLVisualElement(options);\r\n    node.mount(element);\r\n    visualElementStore.set(element, node);\r\n}\r\nfunction createObjectVisualElement(subject) {\r\n    const options = {\r\n        presenceContext: null,\r\n        props: {},\r\n        visualState: {\r\n            renderState: {\r\n                output: {},\r\n            },\r\n            latestValues: {},\r\n        },\r\n    };\r\n    const node = new ObjectVisualElement(options);\r\n    node.mount(subject);\r\n    visualElementStore.set(subject, node);\r\n}\r\n\r\nexport { createDOMVisualElement, createObjectVisualElement };\r\n", "import { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\r\n\r\nfunction animateSingleValue(value, keyframes, options) {\r\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\r\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\r\n    return motionValue$1.animation;\r\n}\r\n\r\nexport { animateSingleValue };\r\n", "import { invariant } from '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { visualElementStore } from '../../render/store.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { animateTarget } from '../interfaces/visual-element-target.mjs';\r\nimport { createDOMVisualElement, createObjectVisualElement } from '../utils/create-visual-element.mjs';\r\nimport { isDOMKeyframes } from '../utils/is-dom-keyframes.mjs';\r\nimport { resolveSubjects } from './resolve-subjects.mjs';\r\nimport { animateSingleValue } from './single-value.mjs';\r\n\r\nfunction isSingleValue(subject, keyframes) {\r\n    return (isMotionValue(subject) ||\r\n        typeof subject === \"number\" ||\r\n        (typeof subject === \"string\" && !isDOMKeyframes(keyframes)));\r\n}\r\n/**\r\n * Implementation\r\n */\r\nfunction animateSubject(subject, keyframes, options, scope) {\r\n    const animations = [];\r\n    if (isSingleValue(subject, keyframes)) {\r\n        animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes)\r\n            ? keyframes.default || keyframes\r\n            : keyframes, options ? options.default || options : options));\r\n    }\r\n    else {\r\n        const subjects = resolveSubjects(subject, keyframes, scope);\r\n        const numSubjects = subjects.length;\r\n        invariant(Boolean(numSubjects), \"No valid elements provided.\");\r\n        for (let i = 0; i < numSubjects; i++) {\r\n            const thisSubject = subjects[i];\r\n            const createVisualElement = thisSubject instanceof Element\r\n                ? createDOMVisualElement\r\n                : createObjectVisualElement;\r\n            if (!visualElementStore.has(thisSubject)) {\r\n                createVisualElement(thisSubject);\r\n            }\r\n            const visualElement = visualElementStore.get(thisSubject);\r\n            const transition = { ...options };\r\n            /**\r\n             * Resolve stagger function if provided.\r\n             */\r\n            if (\"delay\" in transition &&\r\n                typeof transition.delay === \"function\") {\r\n                transition.delay = transition.delay(i, numSubjects);\r\n            }\r\n            animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateSubject };\r\n", "import { spring } from '../generators/spring/index.mjs';\r\nimport { createAnimationsFromSequence } from '../sequence/create.mjs';\r\nimport { animateSubject } from './subject.mjs';\r\n\r\nfunction animateSequence(sequence, options, scope) {\r\n    const animations = [];\r\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring });\r\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\r\n        animations.push(...animateSubject(subject, keyframes, transition));\r\n    });\r\n    return animations;\r\n}\r\n\r\nexport { animateSequence };\r\n", "import { GroupPlaybackControls } from '../../../../../motion-dom/dist/es/animation/controls/Group.mjs';\r\nimport '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { animateSequence } from './sequence.mjs';\r\nimport { animateSubject } from './subject.mjs';\r\n\r\nfunction isSequence(value) {\r\n    return Array.isArray(value) && value.some(Array.isArray);\r\n}\r\n/**\r\n * Creates an animation function that is optionally scoped\r\n * to a specific element.\r\n */\r\nfunction createScopedAnimate(scope) {\r\n    /**\r\n     * Implementation\r\n     */\r\n    function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {\r\n        let animations = [];\r\n        if (isSequence(subjectOrSequence)) {\r\n            animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);\r\n        }\r\n        else {\r\n            animations = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);\r\n        }\r\n        const animation = new GroupPlaybackControls(animations);\r\n        if (scope) {\r\n            scope.animations.push(animation);\r\n        }\r\n        return animation;\r\n    }\r\n    return scopedAnimate;\r\n}\r\nconst animate = createScopedAnimate();\r\n\r\nexport { animate, createScopedAnimate };\r\n", "import '../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { attachTimeline } from './utils/attach-timeline.mjs';\r\n\r\nclass NativeAnimationControls {\r\n    constructor(animation) {\r\n        this.animation = animation;\r\n    }\r\n    get duration() {\r\n        var _a, _b, _c;\r\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\r\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\r\n            300;\r\n        return millisecondsToSeconds(Number(durationInMs));\r\n    }\r\n    get time() {\r\n        var _a;\r\n        if (this.animation) {\r\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\r\n        }\r\n        return 0;\r\n    }\r\n    set time(newTime) {\r\n        if (this.animation) {\r\n            this.animation.currentTime = secondsToMilliseconds(newTime);\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.animation ? this.animation.playbackRate : 1;\r\n    }\r\n    set speed(newSpeed) {\r\n        if (this.animation) {\r\n            this.animation.playbackRate = newSpeed;\r\n        }\r\n    }\r\n    get state() {\r\n        return this.animation ? this.animation.playState : \"finished\";\r\n    }\r\n    get startTime() {\r\n        return this.animation ? this.animation.startTime : null;\r\n    }\r\n    get finished() {\r\n        return this.animation ? this.animation.finished : Promise.resolve();\r\n    }\r\n    play() {\r\n        this.animation && this.animation.play();\r\n    }\r\n    pause() {\r\n        this.animation && this.animation.pause();\r\n    }\r\n    stop() {\r\n        if (!this.animation ||\r\n            this.state === \"idle\" ||\r\n            this.state === \"finished\") {\r\n            return;\r\n        }\r\n        if (this.animation.commitStyles) {\r\n            this.animation.commitStyles();\r\n        }\r\n        this.cancel();\r\n    }\r\n    flatten() {\r\n        var _a;\r\n        if (!this.animation)\r\n            return;\r\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: \"linear\" });\r\n    }\r\n    attachTimeline(timeline) {\r\n        if (this.animation)\r\n            attachTimeline(this.animation, timeline);\r\n        return noop;\r\n    }\r\n    complete() {\r\n        this.animation && this.animation.finish();\r\n    }\r\n    cancel() {\r\n        try {\r\n            this.animation && this.animation.cancel();\r\n        }\r\n        catch (e) { }\r\n    }\r\n}\r\n\r\nexport { NativeAnimationControls };\r\n", "function setCSSVar(element, name, value) {\r\n    element.style.setProperty(name, value);\r\n}\r\nfunction setStyle(element, name, value) {\r\n    element.style[name] = value;\r\n}\r\n\r\nexport { setCSSVar, setStyle };\r\n", "import '../../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { memo } from '../../../../../../../motion-utils/dist/es/memo.mjs';\r\n\r\nconst supportsPartialKeyframes = /*@__PURE__*/ memo(() => {\r\n    try {\r\n        document.createElement(\"div\").animate({ opacity: [1] });\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n});\r\n\r\nexport { supportsPartialKeyframes };\r\n", "import { invariant } from '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { secondsToMilliseconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { createGeneratorEasing } from '../../../../../../motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs';\r\nimport { isGenerator } from '../../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs';\r\nimport { NativeAnimationControls } from '../../../../../../motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs';\r\nimport { supportsLinearEasing } from '../../../../../../motion-dom/dist/es/utils/supports/linear-easing.mjs';\r\nimport { startWaapiAnimation } from './index.mjs';\r\nimport { browserNumberValueTypes } from '../../../render/dom/value-types/number-browser.mjs';\r\nimport { getFinalKeyframe } from './utils/get-final-keyframe.mjs';\r\nimport { setCSSVar, setStyle } from './utils/style.mjs';\r\nimport { supportsPartialKeyframes } from './utils/supports-partial-keyframes.mjs';\r\nimport { supportsWaapi } from './utils/supports-waapi.mjs';\r\n\r\nconst state = new WeakMap();\r\nfunction hydrateKeyframes(valueName, keyframes, read) {\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] === null) {\r\n            keyframes[i] = i === 0 ? read() : keyframes[i - 1];\r\n        }\r\n        if (typeof keyframes[i] === \"number\" &&\r\n            browserNumberValueTypes[valueName]) {\r\n            keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);\r\n        }\r\n    }\r\n    if (!supportsPartialKeyframes() && keyframes.length < 2) {\r\n        keyframes.unshift(read());\r\n    }\r\n}\r\nconst defaultEasing = \"easeOut\";\r\nfunction getElementAnimationState(element) {\r\n    const animationState = state.get(element) || new Map();\r\n    state.set(element, animationState);\r\n    return state.get(element);\r\n}\r\nclass NativeAnimation extends NativeAnimationControls {\r\n    constructor(element, valueName, valueKeyframes, options) {\r\n        const isCSSVar = valueName.startsWith(\"--\");\r\n        invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"framer-motion\"?`);\r\n        const existingAnimation = getElementAnimationState(element).get(valueName);\r\n        existingAnimation && existingAnimation.stop();\r\n        const readInitialKeyframe = () => {\r\n            return valueName.startsWith(\"--\")\r\n                ? element.style.getPropertyValue(valueName)\r\n                : window.getComputedStyle(element)[valueName];\r\n        };\r\n        if (!Array.isArray(valueKeyframes)) {\r\n            valueKeyframes = [valueKeyframes];\r\n        }\r\n        hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);\r\n        // TODO: Replace this with toString()?\r\n        if (isGenerator(options.type)) {\r\n            const generatorOptions = createGeneratorEasing(options, 100, options.type);\r\n            options.ease = supportsLinearEasing()\r\n                ? generatorOptions.ease\r\n                : defaultEasing;\r\n            options.duration = secondsToMilliseconds(generatorOptions.duration);\r\n            options.type = \"keyframes\";\r\n        }\r\n        else {\r\n            options.ease = options.ease || defaultEasing;\r\n        }\r\n        const onFinish = () => {\r\n            this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, options));\r\n            this.cancel();\r\n            this.resolveFinishedPromise();\r\n        };\r\n        const init = () => {\r\n            this.setValue = isCSSVar ? setCSSVar : setStyle;\r\n            this.options = options;\r\n            this.updateFinishedPromise();\r\n            this.removeAnimation = () => {\r\n                const elementState = state.get(element);\r\n                elementState && elementState.delete(valueName);\r\n            };\r\n        };\r\n        if (!supportsWaapi()) {\r\n            super();\r\n            init();\r\n            onFinish();\r\n        }\r\n        else {\r\n            super(startWaapiAnimation(element, valueName, valueKeyframes, options));\r\n            init();\r\n            if (options.autoplay === false) {\r\n                this.animation.pause();\r\n            }\r\n            this.animation.onfinish = onFinish;\r\n            getElementAnimationState(element).set(valueName, this);\r\n        }\r\n    }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n    play() {\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        super.play();\r\n    }\r\n    cancel() {\r\n        this.removeAnimation();\r\n        super.cancel();\r\n    }\r\n}\r\n\r\nexport { NativeAnimation };\r\n", "import { invariant } from '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { secondsToMilliseconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { getValueTransition } from '../../../../../../motion-dom/dist/es/animation/utils/get-value-transition.mjs';\r\nimport { resolveElements } from '../../../../../../motion-dom/dist/es/utils/resolve-elements.mjs';\r\nimport { NativeAnimation } from './NativeAnimation.mjs';\r\n\r\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\r\n    const elements = resolveElements(elementOrSelector, scope);\r\n    const numElements = elements.length;\r\n    invariant(Boolean(numElements), \"No valid element provided.\");\r\n    const animations = [];\r\n    for (let i = 0; i < numElements; i++) {\r\n        const element = elements[i];\r\n        const elementTransition = { ...options };\r\n        /**\r\n         * Resolve stagger function if provided.\r\n         */\r\n        if (typeof elementTransition.delay === \"function\") {\r\n            elementTransition.delay = elementTransition.delay(i, numElements);\r\n        }\r\n        for (const valueName in keyframes) {\r\n            const valueKeyframes = keyframes[valueName];\r\n            const valueOptions = {\r\n                ...getValueTransition(elementTransition, valueName),\r\n            };\r\n            valueOptions.duration = valueOptions.duration\r\n                ? secondsToMilliseconds(valueOptions.duration)\r\n                : valueOptions.duration;\r\n            valueOptions.delay = secondsToMilliseconds(valueOptions.delay || 0);\r\n            animations.push(new NativeAnimation(element, valueName, valueKeyframes, valueOptions));\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateElements };\r\n", "import { GroupPlaybackControls } from '../../../../../../motion-dom/dist/es/animation/controls/Group.mjs';\r\nimport '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { animateElements } from './animate-elements.mjs';\r\n\r\nconst createScopedWaapiAnimate = (scope) => {\r\n    function scopedAnimate(elementOrSelector, keyframes, options) {\r\n        return new GroupPlaybackControls(animateElements(elementOrSelector, keyframes, options, scope));\r\n    }\r\n    return scopedAnimate;\r\n};\r\nconst animateMini = /*@__PURE__*/ createScopedWaapiAnimate();\r\n\r\nexport { animateMini, createScopedWaapiAnimate };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { resolveElements } from '../../../../../../motion-dom/dist/es/utils/resolve-elements.mjs';\r\n\r\nconst resizeHandlers = new WeakMap();\r\nlet observer;\r\nfunction getElementSize(target, borderBoxSize) {\r\n    if (borderBoxSize) {\r\n        const { inlineSize, blockSize } = borderBoxSize[0];\r\n        return { width: inlineSize, height: blockSize };\r\n    }\r\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\r\n        return target.getBBox();\r\n    }\r\n    else {\r\n        return {\r\n            width: target.offsetWidth,\r\n            height: target.offsetHeight,\r\n        };\r\n    }\r\n}\r\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\r\n    var _a;\r\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\r\n        handler({\r\n            target,\r\n            contentSize: contentRect,\r\n            get size() {\r\n                return getElementSize(target, borderBoxSize);\r\n            },\r\n        });\r\n    });\r\n}\r\nfunction notifyAll(entries) {\r\n    entries.forEach(notifyTarget);\r\n}\r\nfunction createResizeObserver() {\r\n    if (typeof ResizeObserver === \"undefined\")\r\n        return;\r\n    observer = new ResizeObserver(notifyAll);\r\n}\r\nfunction resizeElement(target, handler) {\r\n    if (!observer)\r\n        createResizeObserver();\r\n    const elements = resolveElements(target);\r\n    elements.forEach((element) => {\r\n        let elementHandlers = resizeHandlers.get(element);\r\n        if (!elementHandlers) {\r\n            elementHandlers = new Set();\r\n            resizeHandlers.set(element, elementHandlers);\r\n        }\r\n        elementHandlers.add(handler);\r\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\r\n    });\r\n    return () => {\r\n        elements.forEach((element) => {\r\n            const elementHandlers = resizeHandlers.get(element);\r\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\r\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\r\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\r\n            }\r\n        });\r\n    };\r\n}\r\n\r\nexport { resizeElement };\r\n", "const windowCallbacks = new Set();\r\nlet windowResizeHandler;\r\nfunction createWindowResizeHandler() {\r\n    windowResizeHandler = () => {\r\n        const size = {\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        };\r\n        const info = {\r\n            target: window,\r\n            size,\r\n            contentSize: size,\r\n        };\r\n        windowCallbacks.forEach((callback) => callback(info));\r\n    };\r\n    window.addEventListener(\"resize\", windowResizeHandler);\r\n}\r\nfunction resizeWindow(callback) {\r\n    windowCallbacks.add(callback);\r\n    if (!windowResizeHandler)\r\n        createWindowResizeHandler();\r\n    return () => {\r\n        windowCallbacks.delete(callback);\r\n        if (!windowCallbacks.size && windowResizeHandler) {\r\n            windowResizeHandler = undefined;\r\n        }\r\n    };\r\n}\r\n\r\nexport { resizeWindow };\r\n", "import { resizeElement } from './handle-element.mjs';\r\nimport { resizeWindow } from './handle-window.mjs';\r\n\r\nfunction resize(a, b) {\r\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\r\n}\r\n\r\nexport { resize };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { progress } from '../../../../../../motion-utils/dist/es/progress.mjs';\r\nimport { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\r\n\r\n/**\r\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\r\n */\r\nconst maxElapsed = 50;\r\nconst createAxisInfo = () => ({\r\n    current: 0,\r\n    offset: [],\r\n    progress: 0,\r\n    scrollLength: 0,\r\n    targetOffset: 0,\r\n    targetLength: 0,\r\n    containerLength: 0,\r\n    velocity: 0,\r\n});\r\nconst createScrollInfo = () => ({\r\n    time: 0,\r\n    x: createAxisInfo(),\r\n    y: createAxisInfo(),\r\n});\r\nconst keys = {\r\n    x: {\r\n        length: \"Width\",\r\n        position: \"Left\",\r\n    },\r\n    y: {\r\n        length: \"Height\",\r\n        position: \"Top\",\r\n    },\r\n};\r\nfunction updateAxisInfo(element, axisName, info, time) {\r\n    const axis = info[axisName];\r\n    const { length, position } = keys[axisName];\r\n    const prev = axis.current;\r\n    const prevTime = info.time;\r\n    axis.current = element[`scroll${position}`];\r\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\r\n    axis.offset.length = 0;\r\n    axis.offset[0] = 0;\r\n    axis.offset[1] = axis.scrollLength;\r\n    axis.progress = progress(0, axis.scrollLength, axis.current);\r\n    const elapsed = time - prevTime;\r\n    axis.velocity =\r\n        elapsed > maxElapsed\r\n            ? 0\r\n            : velocityPerSecond(axis.current - prev, elapsed);\r\n}\r\nfunction updateScrollInfo(element, info, time) {\r\n    updateAxisInfo(element, \"x\", info, time);\r\n    updateAxisInfo(element, \"y\", info, time);\r\n    info.time = time;\r\n}\r\n\r\nexport { createScrollInfo, updateScrollInfo };\r\n", "function calcInset(element, container) {\r\n    const inset = { x: 0, y: 0 };\r\n    let current = element;\r\n    while (current && current !== container) {\r\n        if (current instanceof HTMLElement) {\r\n            inset.x += current.offsetLeft;\r\n            inset.y += current.offsetTop;\r\n            current = current.offsetParent;\r\n        }\r\n        else if (current.tagName === \"svg\") {\r\n            /**\r\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\r\n             * It would be preferable, given they behave like HTMLElements in most ways\r\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\r\n             * can't use .getBBox() like most SVG elements as these provide the offset\r\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\r\n             */\r\n            const svgBoundingBox = current.getBoundingClientRect();\r\n            current = current.parentElement;\r\n            const parentBoundingBox = current.getBoundingClientRect();\r\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\r\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\r\n        }\r\n        else if (current instanceof SVGGraphicsElement) {\r\n            const { x, y } = current.getBBox();\r\n            inset.x += x;\r\n            inset.y += y;\r\n            let svg = null;\r\n            let parent = current.parentNode;\r\n            while (!svg) {\r\n                if (parent.tagName === \"svg\") {\r\n                    svg = parent;\r\n                }\r\n                parent = current.parentNode;\r\n            }\r\n            current = svg;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return inset;\r\n}\r\n\r\nexport { calcInset };\r\n", "const namedEdges = {\r\n    start: 0,\r\n    center: 0.5,\r\n    end: 1,\r\n};\r\nfunction resolveEdge(edge, length, inset = 0) {\r\n    let delta = 0;\r\n    /**\r\n     * If we have this edge defined as a preset, replace the definition\r\n     * with the numerical value.\r\n     */\r\n    if (edge in namedEdges) {\r\n        edge = namedEdges[edge];\r\n    }\r\n    /**\r\n     * Handle unit values\r\n     */\r\n    if (typeof edge === \"string\") {\r\n        const asNumber = parseFloat(edge);\r\n        if (edge.endsWith(\"px\")) {\r\n            delta = asNumber;\r\n        }\r\n        else if (edge.endsWith(\"%\")) {\r\n            edge = asNumber / 100;\r\n        }\r\n        else if (edge.endsWith(\"vw\")) {\r\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\r\n        }\r\n        else if (edge.endsWith(\"vh\")) {\r\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\r\n        }\r\n        else {\r\n            edge = asNumber;\r\n        }\r\n    }\r\n    /**\r\n     * If the edge is defined as a number, handle as a progress value.\r\n     */\r\n    if (typeof edge === \"number\") {\r\n        delta = length * edge;\r\n    }\r\n    return inset + delta;\r\n}\r\n\r\nexport { namedEdges, resolveEdge };\r\n", "import { resolveEdge, namedEdges } from './edge.mjs';\r\n\r\nconst defaultOffset = [0, 0];\r\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\r\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\r\n    let targetPoint = 0;\r\n    let containerPoint = 0;\r\n    if (typeof offset === \"number\") {\r\n        /**\r\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\r\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\r\n         * and container etc.\r\n         */\r\n        offsetDefinition = [offset, offset];\r\n    }\r\n    else if (typeof offset === \"string\") {\r\n        offset = offset.trim();\r\n        if (offset.includes(\" \")) {\r\n            offsetDefinition = offset.split(\" \");\r\n        }\r\n        else {\r\n            /**\r\n             * If we're provided a definition like \"100px\" then we want to apply\r\n             * that only to the top of the target point, leaving the container at 0.\r\n             * Whereas a named offset like \"end\" should be applied to both.\r\n             */\r\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\r\n        }\r\n    }\r\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\r\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\r\n    return targetPoint - containerPoint;\r\n}\r\n\r\nexport { resolveOffset };\r\n", "const ScrollOffset = {\r\n    Enter: [\r\n        [0, 1],\r\n        [1, 1],\r\n    ],\r\n    Exit: [\r\n        [0, 0],\r\n        [1, 0],\r\n    ],\r\n    Any: [\r\n        [1, 0],\r\n        [0, 1],\r\n    ],\r\n    All: [\r\n        [0, 0],\r\n        [1, 1],\r\n    ],\r\n};\r\n\r\nexport { ScrollOffset };\r\n", "import { clamp } from '../../../../utils/clamp.mjs';\r\nimport { interpolate } from '../../../../utils/interpolate.mjs';\r\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\r\nimport { calcInset } from './inset.mjs';\r\nimport { resolveOffset } from './offset.mjs';\r\nimport { ScrollOffset } from './presets.mjs';\r\n\r\nconst point = { x: 0, y: 0 };\r\nfunction getTargetSize(target) {\r\n    return \"getBBox\" in target && target.tagName !== \"svg\"\r\n        ? target.getBBox()\r\n        : { width: target.clientWidth, height: target.clientHeight };\r\n}\r\nfunction resolveOffsets(container, info, options) {\r\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\r\n    const { target = container, axis = \"y\" } = options;\r\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\r\n    const inset = target !== container ? calcInset(target, container) : point;\r\n    /**\r\n     * Measure the target and container. If they're the same thing then we\r\n     * use the container's scrollWidth/Height as the target, from there\r\n     * all other calculations can remain the same.\r\n     */\r\n    const targetSize = target === container\r\n        ? { width: container.scrollWidth, height: container.scrollHeight }\r\n        : getTargetSize(target);\r\n    const containerSize = {\r\n        width: container.clientWidth,\r\n        height: container.clientHeight,\r\n    };\r\n    /**\r\n     * Reset the length of the resolved offset array rather than creating a new one.\r\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\r\n     */\r\n    info[axis].offset.length = 0;\r\n    /**\r\n     * Populate the offset array by resolving the user's offset definition into\r\n     * a list of pixel scroll offets.\r\n     */\r\n    let hasChanged = !info[axis].interpolate;\r\n    const numOffsets = offsetDefinition.length;\r\n    for (let i = 0; i < numOffsets; i++) {\r\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\r\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\r\n            hasChanged = true;\r\n        }\r\n        info[axis].offset[i] = offset;\r\n    }\r\n    /**\r\n     * If the pixel scroll offsets have changed, create a new interpolator function\r\n     * to map scroll value into a progress.\r\n     */\r\n    if (hasChanged) {\r\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\r\n        info[axis].interpolatorOffsets = [...info[axis].offset];\r\n    }\r\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\r\n}\r\n\r\nexport { resolveOffsets };\r\n", "import { warnOnce } from '../../../utils/warn-once.mjs';\r\nimport { updateScrollInfo } from './info.mjs';\r\nimport { resolveOffsets } from './offsets/index.mjs';\r\n\r\nfunction measure(container, target = container, info) {\r\n    /**\r\n     * Find inset of target within scrollable container\r\n     */\r\n    info.x.targetOffset = 0;\r\n    info.y.targetOffset = 0;\r\n    if (target !== container) {\r\n        let node = target;\r\n        while (node && node !== container) {\r\n            info.x.targetOffset += node.offsetLeft;\r\n            info.y.targetOffset += node.offsetTop;\r\n            node = node.offsetParent;\r\n        }\r\n    }\r\n    info.x.targetLength =\r\n        target === container ? target.scrollWidth : target.clientWidth;\r\n    info.y.targetLength =\r\n        target === container ? target.scrollHeight : target.clientHeight;\r\n    info.x.containerLength = container.clientWidth;\r\n    info.y.containerLength = container.clientHeight;\r\n    /**\r\n     * In development mode ensure scroll containers aren't position: static as this makes\r\n     * it difficult to measure their relative positions.\r\n     */\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        if (container && target && target !== container) {\r\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\r\n        }\r\n    }\r\n}\r\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\r\n    return {\r\n        measure: () => measure(element, options.target, info),\r\n        update: (time) => {\r\n            updateScrollInfo(element, info, time);\r\n            if (options.offset || options.target) {\r\n                resolveOffsets(element, info, options);\r\n            }\r\n        },\r\n        notify: () => onScroll(info),\r\n    };\r\n}\r\n\r\nexport { createOnScrollHandler };\r\n", "import { resize } from '../resize/index.mjs';\r\nimport { createScrollInfo } from './info.mjs';\r\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\r\n\r\nconst scrollListeners = new WeakMap();\r\nconst resizeListeners = new WeakMap();\r\nconst onScrollHandlers = new WeakMap();\r\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\r\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\r\n    let containerHandlers = onScrollHandlers.get(container);\r\n    /**\r\n     * Get the onScroll handlers for this container.\r\n     * If one isn't found, create a new one.\r\n     */\r\n    if (!containerHandlers) {\r\n        containerHandlers = new Set();\r\n        onScrollHandlers.set(container, containerHandlers);\r\n    }\r\n    /**\r\n     * Create a new onScroll handler for the provided callback.\r\n     */\r\n    const info = createScrollInfo();\r\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\r\n    containerHandlers.add(containerHandler);\r\n    /**\r\n     * Check if there's a scroll event listener for this container.\r\n     * If not, create one.\r\n     */\r\n    if (!scrollListeners.has(container)) {\r\n        const measureAll = () => {\r\n            for (const handler of containerHandlers)\r\n                handler.measure();\r\n        };\r\n        const updateAll = () => {\r\n            for (const handler of containerHandlers) {\r\n                handler.update(frameData.timestamp);\r\n            }\r\n        };\r\n        const notifyAll = () => {\r\n            for (const handler of containerHandlers)\r\n                handler.notify();\r\n        };\r\n        const listener = () => {\r\n            frame.read(measureAll, false, true);\r\n            frame.read(updateAll, false, true);\r\n            frame.update(notifyAll, false, true);\r\n        };\r\n        scrollListeners.set(container, listener);\r\n        const target = getEventTarget(container);\r\n        window.addEventListener(\"resize\", listener, { passive: true });\r\n        if (container !== document.documentElement) {\r\n            resizeListeners.set(container, resize(container, listener));\r\n        }\r\n        target.addEventListener(\"scroll\", listener, { passive: true });\r\n    }\r\n    const listener = scrollListeners.get(container);\r\n    frame.read(listener, false, true);\r\n    return () => {\r\n        var _a;\r\n        cancelFrame(listener);\r\n        /**\r\n         * Check if we even have any handlers for this container.\r\n         */\r\n        const currentHandlers = onScrollHandlers.get(container);\r\n        if (!currentHandlers)\r\n            return;\r\n        currentHandlers.delete(containerHandler);\r\n        if (currentHandlers.size)\r\n            return;\r\n        /**\r\n         * If no more handlers, remove the scroll listener too.\r\n         */\r\n        const scrollListener = scrollListeners.get(container);\r\n        scrollListeners.delete(container);\r\n        if (scrollListener) {\r\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\r\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\r\n            window.removeEventListener(\"resize\", scrollListener);\r\n        }\r\n    };\r\n}\r\n\r\nexport { scrollInfo };\r\n", "import { frame, cancelFrame } from '../../../frameloop/frame.mjs';\r\n\r\nfunction observeTimeline(update, timeline) {\r\n    let prevProgress;\r\n    const onFrame = () => {\r\n        const { currentTime } = timeline;\r\n        const percentage = currentTime === null ? 0 : currentTime.value;\r\n        const progress = percentage / 100;\r\n        if (prevProgress !== progress) {\r\n            update(progress);\r\n        }\r\n        prevProgress = progress;\r\n    };\r\n    frame.update(onFrame, true);\r\n    return () => cancelFrame(onFrame);\r\n}\r\n\r\nexport { observeTimeline };\r\n", "import { supportsScrollTimeline } from '../../../../../../motion-dom/dist/es/utils/supports/scroll-timeline.mjs';\r\nimport '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { noop } from '../../../../../../motion-utils/dist/es/noop.mjs';\r\nimport { observeTimeline } from './observe.mjs';\r\nimport { scrollInfo } from './track.mjs';\r\n\r\nfunction scrollTimelineFallback({ source, container, axis = \"y\", }) {\r\n    // Support legacy source argument. Deprecate later.\r\n    if (source)\r\n        container = source;\r\n    // ScrollTimeline records progress as a percentage CSSUnitValue\r\n    const currentTime = { value: 0 };\r\n    const cancel = scrollInfo((info) => {\r\n        currentTime.value = info[axis].progress * 100;\r\n    }, { container, axis });\r\n    return { currentTime, cancel };\r\n}\r\nconst timelineCache = new Map();\r\nfunction getTimeline({ source, container = document.documentElement, axis = \"y\", } = {}) {\r\n    // Support legacy source argument. Deprecate later.\r\n    if (source)\r\n        container = source;\r\n    if (!timelineCache.has(container)) {\r\n        timelineCache.set(container, {});\r\n    }\r\n    const elementCache = timelineCache.get(container);\r\n    if (!elementCache[axis]) {\r\n        elementCache[axis] = supportsScrollTimeline()\r\n            ? new ScrollTimeline({ source: container, axis })\r\n            : scrollTimelineFallback({ source: container, axis });\r\n    }\r\n    return elementCache[axis];\r\n}\r\n/**\r\n * If the onScroll function has two arguments, it's expecting\r\n * more specific information about the scroll from scrollInfo.\r\n */\r\nfunction isOnScrollWithInfo(onScroll) {\r\n    return onScroll.length === 2;\r\n}\r\n/**\r\n * Currently, we only support element tracking with `scrollInfo`, though in\r\n * the future we can also offer ViewTimeline support.\r\n */\r\nfunction needsElementTracking(options) {\r\n    return options && (options.target || options.offset);\r\n}\r\nfunction scrollFunction(onScroll, options) {\r\n    if (isOnScrollWithInfo(onScroll) || needsElementTracking(options)) {\r\n        return scrollInfo((info) => {\r\n            onScroll(info[options.axis].progress, info);\r\n        }, options);\r\n    }\r\n    else {\r\n        return observeTimeline(onScroll, getTimeline(options));\r\n    }\r\n}\r\nfunction scrollAnimation(animation, options) {\r\n    animation.flatten();\r\n    if (needsElementTracking(options)) {\r\n        animation.pause();\r\n        return scrollInfo((info) => {\r\n            animation.time = animation.duration * info[options.axis].progress;\r\n        }, options);\r\n    }\r\n    else {\r\n        const timeline = getTimeline(options);\r\n        if (animation.attachTimeline) {\r\n            return animation.attachTimeline(timeline, (valueAnimation) => {\r\n                valueAnimation.pause();\r\n                return observeTimeline((progress) => {\r\n                    valueAnimation.time = valueAnimation.duration * progress;\r\n                }, timeline);\r\n            });\r\n        }\r\n        else {\r\n            return noop;\r\n        }\r\n    }\r\n}\r\nfunction scroll(onScroll, { axis = \"y\", ...options } = {}) {\r\n    const optionsWithDefaults = { axis, ...options };\r\n    return typeof onScroll === \"function\"\r\n        ? scrollFunction(onScroll, optionsWithDefaults)\r\n        : scrollAnimation(onScroll, optionsWithDefaults);\r\n}\r\n\r\nexport { scroll };\r\n", "import '../../../../../../motion-utils/dist/es/errors.mjs';\r\nimport { resolveElements } from '../../../../../../motion-dom/dist/es/utils/resolve-elements.mjs';\r\n\r\nconst thresholds = {\r\n    some: 0,\r\n    all: 1,\r\n};\r\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\r\n    const elements = resolveElements(elementOrSelector);\r\n    const activeIntersections = new WeakMap();\r\n    const onIntersectionChange = (entries) => {\r\n        entries.forEach((entry) => {\r\n            const onEnd = activeIntersections.get(entry.target);\r\n            /**\r\n             * If there's no change to the intersection, we don't need to\r\n             * do anything here.\r\n             */\r\n            if (entry.isIntersecting === Boolean(onEnd))\r\n                return;\r\n            if (entry.isIntersecting) {\r\n                const newOnEnd = onStart(entry.target, entry);\r\n                if (typeof newOnEnd === \"function\") {\r\n                    activeIntersections.set(entry.target, newOnEnd);\r\n                }\r\n                else {\r\n                    observer.unobserve(entry.target);\r\n                }\r\n            }\r\n            else if (typeof onEnd === \"function\") {\r\n                onEnd(entry);\r\n                activeIntersections.delete(entry.target);\r\n            }\r\n        });\r\n    };\r\n    const observer = new IntersectionObserver(onIntersectionChange, {\r\n        root,\r\n        rootMargin,\r\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\r\n    });\r\n    elements.forEach((element) => observer.observe(element));\r\n    return () => observer.disconnect();\r\n}\r\n\r\nexport { inView };\r\n", "import { clamp } from '../utils/clamp.mjs';\r\n\r\nfunction steps(numSteps, direction = \"end\") {\r\n    return (progress) => {\r\n        progress =\r\n            direction === \"end\"\r\n                ? Math.min(progress, 0.999)\r\n                : Math.max(progress, 0.001);\r\n        const expanded = progress * numSteps;\r\n        const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\r\n        return clamp(0, 1, rounded / numSteps);\r\n    };\r\n}\r\n\r\nexport { steps };\r\n", "import { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\r\n\r\nfunction getOriginIndex(from, total) {\r\n    if (from === \"first\") {\r\n        return 0;\r\n    }\r\n    else {\r\n        const lastIndex = total - 1;\r\n        return from === \"last\" ? lastIndex : lastIndex / 2;\r\n    }\r\n}\r\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {\r\n    return (i, total) => {\r\n        const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\r\n        const distance = Math.abs(fromIndex - i);\r\n        let delay = duration * distance;\r\n        if (ease) {\r\n            const maxDelay = total * duration;\r\n            const easingFunction = easingDefinitionToFunction(ease);\r\n            delay = easingFunction(delay / maxDelay) * maxDelay;\r\n        }\r\n        return startDelay + delay;\r\n    };\r\n}\r\n\r\nexport { getOriginIndex, stagger };\r\n", "import '../../../../motion-utils/dist/es/errors.mjs';\r\nimport { secondsToMilliseconds } from '../../../../motion-utils/dist/es/time-conversion.mjs';\r\nimport { time } from '../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\n/**\r\n * Timeout defined in ms\r\n */\r\nfunction delay(callback, timeout) {\r\n    const start = time.now();\r\n    const checkElapsed = ({ timestamp }) => {\r\n        const elapsed = timestamp - start;\r\n        if (elapsed >= timeout) {\r\n            cancelFrame(checkElapsed);\r\n            callback(elapsed - timeout);\r\n        }\r\n    };\r\n    frame.read(checkElapsed, true);\r\n    return () => cancelFrame(checkElapsed);\r\n}\r\nfunction delayInSeconds(callback, timeout) {\r\n    return delay(callback, secondsToMilliseconds(timeout));\r\n}\r\n\r\nexport { delay, delayInSeconds };\r\n", "const distance = (a, b) => Math.abs(a - b);\r\nfunction distance2D(a, b) {\r\n    // Multi-dimensional\r\n    const xDelta = distance(a.x, b.x);\r\n    const yDelta = distance(a.y, b.y);\r\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\r\n}\r\n\r\nexport { distance, distance2D };\r\n", "import { interpolate } from './interpolate.mjs';\r\n\r\nconst isCustomValueType = (v) => {\r\n    return v && typeof v === \"object\" && v.mix;\r\n};\r\nconst getMixer = (v) => (isCustomValueType(v) ? v.mix : undefined);\r\nfunction transform(...args) {\r\n    const useImmediate = !Array.isArray(args[0]);\r\n    const argOffset = useImmediate ? 0 : -1;\r\n    const inputValue = args[0 + argOffset];\r\n    const inputRange = args[1 + argOffset];\r\n    const outputRange = args[2 + argOffset];\r\n    const options = args[3 + argOffset];\r\n    const interpolator = interpolate(inputRange, outputRange, {\r\n        mixer: getMixer(outputRange[0]),\r\n        ...options,\r\n    });\r\n    return useImmediate ? interpolator(inputValue) : interpolator;\r\n}\r\n\r\nexport { transform };\r\n", "import { stepsOrder } from './order.mjs';\r\nimport { frame, cancelFrame } from './frame.mjs';\r\n\r\n/**\r\n * @deprecated\r\n *\r\n * Import as `frame` instead.\r\n */\r\nconst sync = frame;\r\n/**\r\n * @deprecated\r\n *\r\n * Use cancelFrame(callback) instead.\r\n */\r\nconst cancelSync = stepsOrder.reduce((acc, key) => {\r\n    acc[key] = (process) => cancelFrame(process);\r\n    return acc;\r\n}, {});\r\n\r\nexport { cancelSync, sync };\r\n"],
  "mappings": "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",
  "names": ["undampedFreq", "state", "keys", "state", "progress", "frameData", "state", "steps", "process", "alpha", "progress", "alpha", "color", "mixNumber", "keyframes", "state", "ease", "ease", "ease", "state", "transform", "motionValue", "keyframes", "keyframes", "delay", "keyframes", "isGenerator", "percent", "motionValue", "keyframes", "delay", "progress", "state", "now", "time", "number", "getAnimatableNone", "getAnimatableNone", "motionValue", "keyframes", "delay", "ease", "keyframes", "state", "motionValue", "ease", "state", "now", "getAnimatableNone", "transform", "time", "scale", "progress", "keyframes", "keyframes", "keyframes", "generators", "keyframes", "maxDuration", "delay", "ease", "getValueTransition", "keyframes", "getValueTransition", "delay", "delay", "getValueTransition", "state", "hasTransform", "keys", "state", "isSVGTag", "scrapeMotionValuesFromProps", "scrapeMotionValuesFromProps", "point", "scale", "point", "scale", "distance", "transform", "scroll", "getComputedStyle", "keyframes", "keyframes", "keyframes", "keyframes", "defaultEasing", "keyframes", "getValueTransition", "keyframes", "maxElapsed", "time", "defaultOffset", "time", "notifyAll", "listener", "progress", "progress", "observer", "progress", "ease", "distance", "delay", "getMixer", "process"]
}
